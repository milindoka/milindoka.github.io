<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Time Table App</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8;
        }
        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        .left {
            background-color: #e0f7fa; /* Light Cyan */
            border-right: 1px solid #ccc;
        }
        .right {
            background-color: #fff3e0; /* Light Orange/Peach */
        }
        .divider {
            width: 10px;
            background-color: #ccc;
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .divider::before {
            content: '⋮⋮';
            color: #666;
            font-size: 20px;
            transform: rotate(90deg);
        }
        .value-display {
            font-size: 24px;
            margin-top: 20px;
            font-weight: bold;
            color: #00796b;
        }
        #masterTable {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
        }
        #masterTable th, #masterTable td {
            border: 1px solid #b2dfdb; /* Cyan border */
            padding: 4px;
            text-align: center;
        }
        #masterTable th {
            background-color: #00bcd4; /* Cyan header */
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        .editable-cell {
            width: 100%;
            box-sizing: border-box;
            border: none;
            text-align: center;
            padding: 8px 4px;
            background-color: transparent;
            font-size: 14px;
            text-transform: uppercase;
        }
        .editable-cell:focus {
            outline: 2px solid #ff9800; /* Orange focus */
            background-color: #ffe0b2; /* Light orange background on focus */
        }
        .editable-cell[readonly] {
            background-color: #f0f0f0; /* Light gray background for non-editable cells */
        }
        
        /* Teacher Timetable Styling */
        #timetableDisplay table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
        }
        #timetableDisplay th, #timetableDisplay td {
            border: 1px solid #ffcc80; /* Light orange border */
            padding: 10px;
            text-align: center;
        }
        #timetableDisplay th {
            background-color: #ff9800; /* Orange header */
            color: white;
            font-size: 16px;
        }
        #timetableDisplay .class-cell {
            background-color: #fff8e1; /* Very light orange for class cells */
            font-weight: 600;
            color: #d84315; /* Dark orange text */
        }
        #timetableDisplay .free-cell {
            background-color: #e0e0e0; /* Light gray for free periods */
            color: #616161;
            font-style: italic;
        }
        #timetableDisplay .time-cell {
            font-weight: bold;
            background-color: #ffebcc;
        }

        /* Additional simple styling classes */
        .header-left {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            color: #00796b;
        }
        .controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        .input-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
        }
        .input {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            width: 100%;
            max-width: 20rem;
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }
        .input-small {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            width: 100%;
            max-width: 7rem;
            text-align: center;
            text-transform: uppercase;
        }
        .input:focus {
            outline: 2px solid #f97316;
        }
        .btn-primary {
            background-color: #f97316;
            color: white;
            font-weight: bold;
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-primary:hover {
            background-color: #ea580c;
        }
        .button-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1rem;
        }
        .btn-green {
            background-color: #22c55e;
            color: white;
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-green:hover {
            background-color: #16a34a;
        }
        .btn-blue {
            background-color: #3b82f6;
            color: white;
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-blue:hover {
            background-color: #2563eb;
        }
        .btn-purple {
            background-color: #a855f7;
            color: white;
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-purple:hover {
            background-color: #9333ea;
        }
        .center-buttons {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 1rem;
            gap: 1rem;
        }
        .message-display {
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            color: #00796b;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .progress-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin-bottom: 1rem;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .progress-bar {
            height: 100%;
            background-color: #f97316;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            text-align: center;
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 1rem;
        }
        .btn-gray {
            background-color: #374151;
            color: white;
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-gray:hover {
            background-color: #1f2937;
        }
        .btn-red {
            background-color: #ef4444;
            color: white;
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-red:hover {
            background-color: #dc2626;
        }
        .header-right {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            color: #d84315;
        }
        .full-width {
            width: 100%;
        }
        .center-text {
            text-align: center;
            color: #4b5563;
            margin-top: 2.5rem;
        }
        .error-text {
            text-align: center;
            color: #ef4444;
            margin-top: 2.5rem;
            font-weight: 500;
        }
        .header-teacher {
            font-size: 1.5rem;
            font-weight: 800;
            text-align: center;
            color: #d84315;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .clash-info {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: left;
            color: #e91e63;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #fce4ec;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

    </style>
</head>
<body>

    <div class="panel left">

        <div class="controls">
            <div class="input-row">
                <input type="text" id="teacherCodeInput" maxlength="2" placeholder="Enter Teacher Code (e.g., MO)" class="input-small">
                <button id="generateBtn" class="btn-primary">
                    Generate Time Table
                </button>
            </div>
        </div>

        <div class="button-row">
            <button onclick="loadDefaultData()" class="btn-green">Load Sample Data</button>
            <button onclick="newTimeTable()" class="btn-red">New Time Table</button>
            <button onclick="saveToFile()" class="btn-blue">Save Table</button>
            <input type="file" id="fileInput" accept=".html" style="display: none;">
            <button onclick="loadFromFile()" class="btn-purple">Load Table</button>
            <button onclick="printCurrent()" class="btn-gray">Print Current</button>
            <button onclick="printAllTeachers()" class="btn-gray">Print All Teachers</button>
            <button onclick="printAllClasses()" class="btn-gray">Print All Classes</button>
            <button id="removeClashesBtn" onclick="removeClashes()" class="btn-red">Remove Clashes</button>
            <button id="optimizeBtn" onclick="toggleOptimization()" class="btn-green">Optimize</button>
        </div>

        <div class="center-buttons">
            <button onclick="addRow()" class="btn-gray">Add Time Slot</button>
            <button onclick="addClassRow()" class="btn-blue">Add Class Row</button>
            <button onclick="deleteRow()" class="btn-red">Delete Last Slot</button>
        </div>

        <div id="messageDiv" class="message-display">File : Demo Time Table</div>
        
        <div id="progressContainer" class="progress-container" style="display: none;">
            <div id="progressBar" class="progress-bar"></div>
        </div>
        <div id="progressText" class="progress-text" style="display: none;">Removing clashes...</div>

        <table id="masterTable">
            <thead>
                <tr>
                    <th>Master</th>
                    <th>Mon</th>
                    <th>Tue</th>
                    <th>Wed</th>
                    <th>Thu</th>
                    <th>Fri</th>
                    <th>Sat</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

    <div class="divider"></div>

    <div class="panel right">
        <div id="timetableDisplay" class="full-width">
            <p class="center-text">
                Enter a teacher code and click 'Generate Time Table' to see their personalized schedule here.
            </p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            loadDefaultData(); // Load sample data on startup
            document.getElementById('generateBtn').addEventListener('click', generateTeacherTimetable);
            addKeyboardNavigation(); // Add keyboard navigation to inputs
            addDividerDrag(); // Add divider drag functionality
        });

        const COLUMNS = ['Time', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

        let currentFileName = '';

        // --- Core Time Table Generation Logic ---

        /**
         * Parses the master table, extracts the schedule for a specific teacher, and returns the HTML.
         */
        function getTeacherTimetableHTML(teacherCode) {
            let html = '';
            
            if (teacherCode.length !== 2) {
                html = `<p class="error-text">
                    Please enter a valid two-character teacher code (e.g., MO, CN).
                </p>`;
                return html;
            }

            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            if (rows.length === 0) {
                html = `<p class="center-text">
                    Master Time Table is empty. Please load or input data first.
                </p>`;
                return html;
            }

            // 1. Extract and Structure Master Data
            const timeSlots = [];
            let currentSlot = null;

            // Iterate over every two rows (Time Row and Section/Class Rows)
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                
                // First cell contains either Time (10:00-11:00) or Section (FY-A)
                const firstCell = cells[0].value.trim();

                // Check if this is a new Time Slot Row (e.g., 10:00-11:00)
                if (firstCell.includes('-') && firstCell.includes(':')) {
                    if (currentSlot) {
                        timeSlots.push(currentSlot);
                    }
                    currentSlot = {
                        time: firstCell,
                        sections: []
                    };
                } 
                // Check if this is a Section Row (e.g., FY-A)
                else if (currentSlot && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const sectionSchedule = {
                        section: firstCell,
                        schedule: {}
                    };
                    
                    // Iterate through Mon to Sat (indices 1 to 6)
                    for (let j = 1; j < COLUMNS.length; j++) {
                        sectionSchedule.schedule[COLUMNS[j]] = cells[j].value.trim();
                    }
                    currentSlot.sections.push(sectionSchedule);
                }
            }
            // Push the last slot
            if (currentSlot) {
                timeSlots.push(currentSlot);
            }

            // 2. Build the Teacher's Personal Schedule
            const teacherSchedule = {};
            const counts = {}; // For subcounts
            let clashCount = 0; // Initialize clash counter

            timeSlots.forEach(slot => {
                const time = slot.time;
                teacherSchedule[time] = {};

                COLUMNS.slice(1).forEach(day => { // Iterate Mon through Sat
                    let assignments = [];

                    slot.sections.forEach(sectionData => {
                        const classValue = sectionData.schedule[day]; // e.g., 'MAT(MO),ECO(ZP)'

                        const parts = classValue.split(',');
                        parts.forEach(part => {
                            const trimmed = part.trim();
                            if (trimmed.match(new RegExp(`\\(${teacherCode}\\)$`, 'i'))) {
                                const subject = trimmed.split('(')[0];
                                assignments.push(`${subject} (${sectionData.section})`);
                            }
                        });
                    });

                    const sectionInfo = assignments.length > 0 ? assignments.join('<br>') : 'Free';
                    teacherSchedule[time][day] = sectionInfo;

                    // Count clashes: if more than one assignment in this time slot and day
                    if (assignments.length > 1) {
                        clashCount++;
                    }

                    // Collect counts
                    if (assignments.length > 0) {
                        assignments.forEach(ass => {
                            const parts = ass.split(' (');
                            const subject = parts[0];
                            const section = parts[1].slice(0, -1);
                            if (!counts[section]) counts[section] = {};
                            counts[section][subject] = (counts[section][subject] || 0) + 1;
                        });
                    }
                });
            });

            // Filter out time slots where all days are 'Free'
            const timeSlotsKeys = Object.keys(teacherSchedule);
            const filteredTimes = timeSlotsKeys.filter(time => {
                return COLUMNS.slice(1).some(day => teacherSchedule[time][day] !== 'Free');
            });

            // Calculate period count
            let periodCount = 0;
            filteredTimes.forEach(time => {
                COLUMNS.slice(1).forEach(day => {
                    if (teacherSchedule[time][day] !== 'Free') {
                        periodCount++;
                    }
                });
            });

            // Calculate gap count (free periods excluding beginning and end)
            let gapCount = 0;
            COLUMNS.slice(1).forEach(day => {
                const dayPeriods = [];
                filteredTimes.forEach(time => {
                    dayPeriods.push(teacherSchedule[time][day] === 'Free' ? 'Free' : 'Busy');
                });

                let firstBusy = -1;
                let lastBusy = -1;
                for (let i = 0; i < dayPeriods.length; i++) {
                    if (dayPeriods[i] === 'Busy') {
                        if (firstBusy === -1) firstBusy = i;
                        lastBusy = i;
                    }
                }

                if (firstBusy !== -1 && lastBusy !== -1) {
                    for (let i = firstBusy + 1; i < lastBusy; i++) {
                        if (dayPeriods[i] === 'Free') gapCount++;
                    }
                }
            });

            // Calculate doubles count (sections assigned multiple times on the same day)
            let doublesCount = 0;
            COLUMNS.slice(1).forEach(day => {
                const dayAssignments = {};
                filteredTimes.forEach(time => {
                    const content = teacherSchedule[time][day];
                    if (content !== 'Free') {
                        const lines = content.split('<br>');
                        lines.forEach(line => {
                            const parts = line.split(' (');
                            if (parts.length > 1) {
                                const section = parts[1].slice(0, -1);
                                if (!dayAssignments[section]) dayAssignments[section] = 0;
                                dayAssignments[section]++;
                            }
                        });
                    }
                });
                Object.values(dayAssignments).forEach(count => {
                    if (count > 1) doublesCount++;
                });
            });

            html += `<p class="clash-info">Clashes : ${clashCount} &nbsp;&nbsp;&nbsp; Doubles : ${doublesCount} &nbsp;&nbsp;&nbsp; Gaps : ${gapCount}</p>`;

            html += `
                <table>
                    <thead>
                        <tr>
                            <th>${teacherCode}-${periodCount}</th>
                            ${COLUMNS.slice(1).map(day => `<th>${day}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            if (filteredTimes.length === 0) {
                html = `<p class="error-text">
                    No time slots defined in the Master Table.
                </p>`;
            } else {
                filteredTimes.forEach(time => {
                    html += `<tr><td class="time-cell">${time}</td>`;
                    COLUMNS.slice(1).forEach(day => {
                        const content = teacherSchedule[time][day];
                        const cellClass = content === 'Free' ? 'free-cell' : 'class-cell';
                        html += `<td class="${cellClass}">${content.replace(/,/g, '<br>')}</td>`;
                    });
                    html += `</tr>`;
                });
            }

            html += `</tbody></table>`;

            // Add summary table
            let summaryHTML = '<table style="margin-top: 20px;"><thead><tr><th>Section</th><th>Subject</th><th>Periods</th></tr></thead><tbody>';
            for (let section in counts) {
                for (let subject in counts[section]) {
                    summaryHTML += `<tr><td>${section}</td><td>${subject}</td><td>${counts[section][subject]}</td></tr>`;
                }
            }
            summaryHTML += '</tbody></table>';
            html += summaryHTML;

            return html;
        }

        /**
         * Parses the master table, extracts the schedule for a specific teacher, and displays it.
         */
        function generateTeacherTimetable() {
            const teacherCode = document.getElementById('teacherCodeInput').value.trim().toUpperCase();
            const displayDiv = document.getElementById('timetableDisplay');
            displayDiv.innerHTML = getTeacherTimetableHTML(teacherCode);
        }

        /**
         * Parses the master table, extracts the schedule for a specific section, and displays it.
         */
        function generateClassTimetable(sectionName) {
            const displayDiv = document.getElementById('timetableDisplay');
            
            if (sectionName.length === 0) {
                displayDiv.innerHTML = `<p class="error-text">
                    Please enter a valid section name.
                </p>`;
                return;
            }

            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            if (rows.length === 0) {
                displayDiv.innerHTML = `<p class="center-text">
                    Master Time Table is empty. Please load or input data first.
                </p>`;
                return;
            }

            const classSchedule = {};
            const counts = {}; // For subcounts
            let currentTimeSlot = null;

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                // Check for Time Slot Row (e.g., 10:00-11:00)
                if (firstCell.includes('-') && firstCell.includes(':')) {
                    currentTimeSlot = firstCell; // Update the current time slot
                    classSchedule[currentTimeSlot] = null; // Initialize slot
                }
                // Check for Section Row (e.g., FY-A) and if it matches the target section
                else if (currentTimeSlot && firstCell.toUpperCase() === sectionName.toUpperCase()) {
                    const dailySchedule = {};
                    // Iterate through Mon to Sat (indices 1 to 6)
                    for (let j = 1; j < COLUMNS.length; j++) {
                        const classValue = cells[j].value.trim();
                        // Store the result for this Time/Day
                        dailySchedule[COLUMNS[j]] = classValue || 'Free';
                        // Collect counts
                        if (classValue && classValue !== 'Free') {
                            const subject = classValue.split('(')[0];
                            counts[subject] = (counts[subject] || 0) + 1;
                        }
                    }
                    classSchedule[currentTimeSlot] = dailySchedule;
                    currentTimeSlot = null; // Reset current time slot to avoid mis-association with following rows
                }
            });

            // Calculate total periods
            let totalPeriods = 0;
            for (let subject in counts) {
                totalPeriods += counts[subject];
            }

            // 3. Render the Output Table
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>${sectionName.toUpperCase()}-${totalPeriods}</th>
                            ${COLUMNS.slice(1).map(day => `<th>${day}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            const timeSlotsKeys = Object.keys(classSchedule);
            const filteredTimes = timeSlotsKeys.filter(time => {
                const schedule = classSchedule[time];
                return schedule && COLUMNS.slice(1).some(day => schedule[day] !== 'Free');
            });
            if (filteredTimes.length === 0) {
                html = `<p class="error-text">
                    Section **${sectionName.toUpperCase()}** not found in the Master Table.
                </p>`;
            } else {
                filteredTimes.forEach(time => {
                    const schedule = classSchedule[time];
                    if (schedule) {
                        html += `<tr><td class="time-cell">${time}</td>`;
                        COLUMNS.slice(1).forEach(day => {
                            const content = schedule[day];
                            const isFree = content.toUpperCase() === 'FREE' || content === '';
                            // Use light cyan colors for the class timetable for visual distinction
                            const cellClass = isFree ? 'free-cell' : 'class-cell';
                            html += `<td class="${cellClass}" style="background-color: ${isFree ? '#e0f7fa' : '#b2ebf2'}; color: #00796b; font-weight: ${isFree ? 'normal' : '600'};">${(content || 'Free').replace(/,/g, '<br>')}</td>`;
                        });
                        html += `</tr>`;
                    }
                });
            }

            html += `</tbody></table>`;

            // Add summary table
            let summaryHTML = '<table style="margin-top: 20px;"><thead><tr><th>Section</th><th>Subject</th><th>Periods</th></tr></thead><tbody>';
            for (let subject in counts) {
                summaryHTML += `<tr><td>${sectionName.toUpperCase()}</td><td>${subject}</td><td>${counts[subject]}</td></tr>`;
            }
            summaryHTML += '</tbody></table>';
            html += summaryHTML;

            displayDiv.innerHTML = html;
        }


        // --- Keyboard Navigation Function ---

        function addKeyboardNavigation() {
            const inputs = document.querySelectorAll('.editable-cell');
            inputs.forEach((input, index) => {
                input.addEventListener('keydown', handleKey);
                // Attach handleFocus to all cells (including the first column)
                input.addEventListener('focus', handleFocus); 
            });
        }

        function handleKey(event) {
            const key = event.key;
            if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(key)) return;

            event.preventDefault();

            const inputs = Array.from(document.querySelectorAll('.editable-cell'));
            const currentIndex = inputs.indexOf(event.target);
            const rowLength = COLUMNS.length; // 7
            const totalInputs = inputs.length;
            let newIndex;

            if (key === 'ArrowLeft') {
                const col = currentIndex % rowLength;
                if (col === 0) {
                    newIndex = currentIndex + rowLength - 1;
                } else {
                    newIndex = currentIndex - 1;
                }
            } else if (key === 'ArrowRight') {
                const col = currentIndex % rowLength;
                if (col === rowLength - 1) {
                    newIndex = currentIndex - rowLength + 1;
                } else {
                    newIndex = currentIndex + 1;
                }
            } else if (key === 'ArrowUp') {
                newIndex = currentIndex - rowLength;
                if (newIndex < 0) {
                    newIndex += totalInputs;
                }
            } else if (key === 'ArrowDown') {
                newIndex = currentIndex + rowLength;
                if (newIndex >= totalInputs) {
                    newIndex -= totalInputs;
                }
            }

            // Skip readonly cells for all arrow key movements
            let targetIndex = newIndex;
            const isVertical = key === 'ArrowUp' || key === 'ArrowDown';
            const step = isVertical ? (key === 'ArrowUp' ? -rowLength : rowLength) : (key === 'ArrowLeft' ? -1 : 1);
            if (inputs[targetIndex] && inputs[targetIndex].readOnly) {
                let originalIndex = currentIndex;
                do {
                    targetIndex += step;
                    if (isVertical) {
                        if (targetIndex < 0) targetIndex += totalInputs;
                        if (targetIndex >= totalInputs) targetIndex -= totalInputs;
                    } else {
                        // For horizontal, wrap within row
                        const rowStart = Math.floor(currentIndex / rowLength) * rowLength;
                        const rowEnd = rowStart + rowLength - 1;
                        if (targetIndex < rowStart) targetIndex = rowEnd;
                        if (targetIndex > rowEnd) targetIndex = rowStart;
                    }
                } while (inputs[targetIndex].readOnly && targetIndex !== originalIndex); // Prevent infinite loop
            }

            inputs[targetIndex].focus();
        }

        // Function to handle focus on editable cells
        function handleFocus(event) {
            const input = event.target;

            // If the cell is non-editable (readonly), move focus to the next row's cell in the same column
            if (input.readOnly) {
                const cell = input.closest('td');
                const row = cell.closest('tr');
                const tableBody = row.closest('tbody');
                const rows = Array.from(tableBody.querySelectorAll('tr'));
                const currentRowIndex = rows.indexOf(row);
                if (currentRowIndex < rows.length - 1) {
                    const nextRow = rows[currentRowIndex + 1];
                    const nextCell = nextRow.cells[cell.cellIndex];
                    if (nextCell) {
                        const nextInput = nextCell.querySelector('.editable-cell');
                        if (nextInput) {
                            nextInput.focus();
                            return; // Prevent further processing
                        }
                    }
                }
            }

            const value = input.value.trim();
            const cell = input.closest('td');
            const colIndex = cell.cellIndex;

            // Logic for Day columns (Mon-Sat, colIndex > 0)
            if (colIndex > 0) {
                const teacherMatches = value.match(/\((..)\)/g);
                if (teacherMatches && teacherMatches.length > 1) {
                    // Split class: show timetables for all teachers vertically
                    const teachers = teacherMatches.map(m => m.slice(1, -1).toUpperCase());
                    let html = '';
                    teachers.forEach(teacher => {
                        html += getTeacherTimetableHTML(teacher);
                    });
                    document.getElementById('timetableDisplay').innerHTML = html;
                } else {
                    // Single teacher: original logic
                    const match = value.match(/^(.+)\((..)\)$/); // e.g., MAT(MO)
                    if (match) {
                        const teacherCode = match[2].toUpperCase();
                        document.getElementById('teacherCodeInput').value = teacherCode;
                        generateTeacherTimetable();
                    }
                }
            }
            // Logic for First column (Time/Section, colIndex == 0)
            else if (colIndex === 0) {
                // Check if the value is NOT a time slot (e.g., '10:00-11:00') - meaning it's a section name
                if (!value.includes('-') || !value.includes(':')) {
                    const sectionName = value.toUpperCase();
                    if (sectionName !== '' && sectionName.toUpperCase() !== 'LUNCH') {
                        // Run the new function to generate the class timetable
                        generateClassTimetable(sectionName);
                    }
                }
            }

            // Track the last focused editable cell
            if (input.classList.contains('editable-cell')) {
                lastFocusedEditableCell = input;
            }
        }


        // --- Auxiliary Functions (Kept from original file) ---

        function loadDefaultData() {
            const defaultData = [
                // Time Slot Row, Section Row 1 (FY-A), Section Row 2 (FY-B)
                ['10:00-11:00', '', '', '', '', '', ''],
                ['FY-A', 'MAT(MO),ECO(ZP)', 'CHE(CN)', 'MAT(MO)', 'MAT(MO)', 'CHE(CN)', 'MAT(MO)'],
                ['FY-B', 'PHY(TM)', 'MAT(MO)', 'PHY(TM)', 'CHE(CN)', 'MAT(MO)', 'PHY(TM)'],
                ['11:00-12:00', '', '', '', '', '', ''],

                ['FY-A', 'MAT(MO)', 'PHY(TM)', 'PHY(TM)', 'CHE(CN)', 'CHE(CN)', 'PHY(TM)'],
                ['FY-B', 'MAT(MO)', 'MAT(MO)', 'PHY(TM)', 'MAT(MO)', 'MAT(MO)', 'MAT(MO)'],
               
                ['12:00-01:00', '', '', '', '', '', ''],
                ['FY-A', 'CHE(CN)', 'PHY(TM)', 'MAT(MO)', 'MAT(MO)', 'PHY(TM)', 'CHE(CN)'],
                ['FY-B', 'MAT(MO)', 'MAT(MO)', 'CHE(CN)', 'PHY(TM)', 'MAT(MO)', 'PHY(TM)'],
                
                // Lunch Break Row (just for separation, not counted as classes)
                ['01:00-02:00', 'LUNCH', 'LUNCH', 'LUNCH', 'LUNCH', 'LUNCH', 'LUNCH', 'LUNCH'],

                ['02:00-03:00', '', '', '', '', '', ''],
                ['FY-A', 'PHY(TM)', 'MAT(MO)', 'CHE(CN)', 'PHY(TM)', 'MAT(MO)', 'MAT(MO)'],
                ['FY-B', 'CHE(CN)', 'PHY(TM)', 'MAT(MO)', 'PHY(TM)', 'PHY(TM)', 'CHE(CN)'],
            ];

            const masterTableBody = document.querySelector('#masterTable tbody');
            masterTableBody.innerHTML = ''; // Clear existing rows
            
            defaultData.forEach((rowData, index) => {
                const newRow = masterTableBody.insertRow();
                const isTimeSlotRow = rowData[0].includes('-') && rowData[0].includes(':');
                for (let i = 0; i < COLUMNS.length; i++) {
                    const newCell = newRow.insertCell();
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'editable-cell';
                    input.value = rowData[i] !== undefined ? rowData[i] : '';
                    if (isTimeSlotRow && i > 0) {
                        input.readOnly = true; // Make day cells non-editable for time slot rows
                        input.placeholder = '';
                    } else {
                        input.placeholder = i === 0 ? (isTimeSlotRow ? 'Time Slot' : 'Section Name') : 'SUB(TR)';
                    }
                    newCell.appendChild(input);
                    input.addEventListener('keydown', handleKey);
                    // All cells now have the focus listener
                    input.addEventListener('focus', handleFocus);
                }
            });
            addKeyboardNavigation(); // Re-add listeners after loading
            const clashes = findAllClashes();
            const doubles = findAllDoubles();
            const gaps = findAllGaps();
            document.getElementById('messageDiv').textContent = 'File : Demo Time Table [ Clashes ' + clashes.length + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
            currentFileName = 'Demo Time Table';
        }

        function newTimeTable() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            masterTableBody.innerHTML = ''; // Clear all rows
            const displayDiv = document.getElementById('timetableDisplay');
            displayDiv.innerHTML = `<p class="center-text">
                Enter a teacher code and click 'Generate Time Table' to see their personalized schedule here.
            </p>`;
            document.getElementById('teacherCodeInput').value = ''; // Clear input field
            document.getElementById('messageDiv').textContent = 'File : New Time Table [ Clashes 0 | Doubles 0 | Gaps 0 ]';
            currentFileName = 'New Time Table';
        }

        
        // Simplified row handling for this specific master table format (Time Row followed by one or more Section Rows)
        function addRow() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const newRowTime = masterTableBody.insertRow();
            const newRowSection = masterTableBody.insertRow();

            // Row 1: Time Slot Header (e.g., 03:00-04:00)
            for (let i = 0; i < COLUMNS.length; i++) {
                const newCell = newRowTime.insertCell();
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'editable-cell';
                input.value = i === 0 ? 'XX:XX-XX:XX' : '';
                if (i > 0) {
                    input.readOnly = true;
                    input.placeholder = '';
                } else {
                    input.placeholder = 'Time Slot';
                }
                newCell.appendChild(input);
                input.addEventListener('keydown', handleKey);
                input.addEventListener('focus', handleFocus);
            }

            // Row 2: First Section (e.g., FY-A)
            for (let i = 0; i < COLUMNS.length; i++) {
                const newCell = newRowSection.insertCell();
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'editable-cell';
                input.value = i === 0 ? 'FY-C' : '';
                input.placeholder = i === 0 ? 'Section Name' : 'SUB(TR)';
                newCell.appendChild(input);
                input.addEventListener('keydown', handleKey);
                input.addEventListener('focus', handleFocus);
            }
        }

        function addClassRow() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const newRow = masterTableBody.insertRow();

            // Add a single section row
            for (let i = 0; i < COLUMNS.length; i++) {
                const newCell = newRow.insertCell();
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'editable-cell';
                input.value = '';
                input.placeholder = i === 0 ? 'Section Name' : 'SUB(TR)';
                newCell.appendChild(input);
                input.addEventListener('keydown', handleKey);
                input.addEventListener('focus', handleFocus);
            }
        }
        
        function deleteRow() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = masterTableBody.querySelectorAll('tr');
            if (rows.length > 0) {
                // Determine if the last row is a time slot or a section row
                // This is a simplification; ideally, you'd delete a whole time slot block (Time row + all Section rows)
                masterTableBody.deleteRow(rows.length - 1);
            }
        }


        // --- File I/O Functions (Simplified for Canvas) ---

        function saveToFile() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = masterTableBody.querySelectorAll('tr');
            const data = [];

            rows.forEach(row => {
                const rowData = Array.from(row.querySelectorAll('.editable-cell')).map(input => input.value);
                data.push(rowData);
            });

            // Create a temporary HTML document structure to encapsulate the table data with improved appearance
            const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Master Time Table Data</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        table { border-collapse: collapse; width: 100%; margin: 0 auto; }
        th, td { border: 1px solid black; padding: 8px; text-align: center; }
        th { background-color: #f0f0f0; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Master Time Table</h1>
    <table id="masterTableData">
        <thead>
            <tr>
                <th>Time/Section</th>
                <th>Mon</th>
                <th>Tue</th>
                <th>Wed</th>
                <th>Thu</th>
                <th>Fri</th>
                <th>Sat</th>
            </tr>
        </thead>
        <tbody>
            ${data.map(rowData =>
                `<tr>${rowData.map(cell => `<td>${cell.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/,/g, '<br>')}</td>`).join('')}</tr>`
            ).join('')}
        </tbody>
    </table>
</body>
</html>
            `.trim();

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'master_timetable.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.html';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const htmlString = event.target.result;
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlString, 'text/html');
                        const dataTable = doc.getElementById('masterTableData');

                        if (dataTable) {
                            const masterTableBody = document.querySelector('#masterTable tbody');
                            masterTableBody.innerHTML = ''; // Clear existing rows

                            const allRows = Array.from(dataTable.querySelectorAll('tr'));
                            let dataRows = allRows;

                            // Check if the first row is the header row
                            if (allRows.length > 0) {
                                const firstRowCells = Array.from(allRows[0].querySelectorAll('td, th'));
                                if (firstRowCells.length === COLUMNS.length && firstRowCells[0].textContent === 'Time/Section') {
                                    dataRows = allRows.slice(1); // Skip the header row
                                }
                            }

                            dataRows.forEach(dataRow => {
                                const rowCells = Array.from(dataRow.querySelectorAll('td'));
                                if (rowCells.length === COLUMNS.length) {
                                    const rowValues = rowCells.map(cell => cell.textContent);

                                    const newRow = masterTableBody.insertRow();
                                    const isTimeSlotRow = rowValues[0].includes('-') && rowValues[0].includes(':');
                                    for (let i = 0; i < COLUMNS.length; i++) {
                                        const newCell = newRow.insertCell();
                                        const input = document.createElement('input');
                                        input.type = 'text';
                                        input.className = 'editable-cell';
                                        input.value = rowValues[i];
                                        if (isTimeSlotRow && i > 0) {
                                            input.readOnly = true;
                                            input.placeholder = '';
                                        } else {
                                            input.placeholder = i === 0 ? (isTimeSlotRow ? 'Time Slot' : 'Section Name') : 'SUB(TR)';
                                        }
                                        newCell.appendChild(input);
                                        input.addEventListener('keydown', handleKey);
                                        input.addEventListener('focus', handleFocus);
                                    }
                                } else {
                                    console.error("Skipping malformed row during load: expected " + COLUMNS.length + " cells, got " + rowCells.length);
                                }
                            });
                            addKeyboardNavigation(); // Add listeners after loading from file
                            const clashes = findAllClashes();
                            const doubles = findAllDoubles();
                            const gaps = findAllGaps();
                            document.getElementById('messageDiv').textContent = 'File : ' + file.name + ' [ Clashes ' + clashes.length + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
                            currentFileName = file.name;
                        } else {
                            alert("Error: The loaded file does not contain a recognizable timetable data table.");
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        /**
         * Extracts all unique teacher codes from the master table
         */
        function getAllTeacherCodes() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            const teachers = new Set();

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                // Skip time slots and lunch rows
                if ((firstCell.includes('-') && firstCell.includes(':')) || firstCell.toUpperCase() === 'LUNCH') {
                    return;
                }

                // Extract teacher codes from day columns
                for (let j = 1; j < cells.length; j++) {
                    const cellValue = cells[j].value.trim();
                    // Find all teacher codes like (MO), (CN), (TM), (ZP)
                    const matches = cellValue.match(/\(([A-Z]{2})\)/g);
                    if (matches) {
                        matches.forEach(match => {
                            teachers.add(match.slice(1, -1));
                        });
                    }
                }
            });

            return Array.from(teachers).sort();
        }

        /**
         * Extracts all unique section names from the master table
         */
        function getAllSections() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            const sections = new Set();

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                // Skip time slots and lunch rows, extract section names
                if (!((firstCell.includes('-') && firstCell.includes(':')) || firstCell.toUpperCase() === 'LUNCH') && firstCell !== '') {
                    sections.add(firstCell.toUpperCase());
                }
            });

            return Array.from(sections).sort();
        }

        /**
         * Displays all teacher timetables serially in a single document
         */
        function printAllTeachers() {
            const teachers = getAllTeacherCodes();
            
            if (teachers.length === 0) {
                alert('No teachers found in the master timetable.');
                return;
            }

            let combinedHTML = '';
            teachers.forEach((teacher, index) => {
                combinedHTML += getTeacherTimetableHTML(teacher);
                if (index < teachers.length - 1) {
                    combinedHTML += '<div style="page-break-after: always; margin-top: 40px;"></div>';
                }
            });

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Print All Teachers Timetables</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        table { border-collapse: collapse; width: 100%; margin: 20px auto; }
                        th, td { border: 1px solid black; padding: 8px; text-align: center; }
                        th { background-color: #f0f0f0; font-weight: bold; }
                        .time-cell { font-weight: bold; background-color: #ffebcc; }
                        .class-cell { background-color: #fff8e1; font-weight: 600; color: #d84315; }
                        .free-cell { background-color: #e0e0e0; color: #616161; font-style: italic; }
                        @media print {
                            .page-break { page-break-after: always; }
                        }
                    </style>
                </head>
                <body>
                    ${combinedHTML}
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        /**
         * Displays all class timetables serially in a single document
         */
        function printAllClasses() {
            const sections = getAllSections();
            
            if (sections.length === 0) {
                alert('No sections found in the master timetable.');
                return;
            }

            let combinedHTML = '';
            sections.forEach((section, index) => {
                combinedHTML += getClassTimetableHTML(section);
                if (index < sections.length - 1) {
                    combinedHTML += '<div style="page-break-after: always; margin-top: 40px;"></div>';
                }
            });

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Print All Classes Timetables</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        table { border-collapse: collapse; width: 100%; margin: 20px auto; }
                        th, td { border: 1px solid black; padding: 8px; text-align: center; }
                        th { background-color: #f0f0f0; font-weight: bold; }
                        .time-cell { font-weight: bold; background-color: #ffebcc; }
                        .class-cell { background-color: #fff8e1; font-weight: 600; color: #d84315; }
                        .free-cell { background-color: #e0e0e0; color: #616161; font-style: italic; }
                        @media print {
                            .page-break { page-break-after: always; }
                        }
                    </style>
                </head>
                <body>
                    ${combinedHTML}
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        /**
         * Generates HTML for a class/section timetable (used by printAllClasses)
         */
        function getClassTimetableHTML(sectionName) {
            if (sectionName.length === 0) {
                return `<p class="error-text">Please enter a valid section name.</p>`;
            }

            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            if (rows.length === 0) {
                return `<p class="center-text">Master Time Table is empty. Please load or input data first.</p>`;
            }

            const classSchedule = {};
            const counts = {};
            let currentTimeSlot = null;

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    currentTimeSlot = firstCell;
                    classSchedule[currentTimeSlot] = null;
                } else if (currentTimeSlot && firstCell.toUpperCase() === sectionName.toUpperCase()) {
                    const dailySchedule = {};
                    for (let j = 1; j < COLUMNS.length; j++) {
                        const classValue = cells[j].value.trim();
                        dailySchedule[COLUMNS[j]] = classValue || 'Free';
                        if (classValue && classValue !== 'Free') {
                            const subject = classValue.split('(')[0];
                            counts[subject] = (counts[subject] || 0) + 1;
                        }
                    }
                    classSchedule[currentTimeSlot] = dailySchedule;
                    currentTimeSlot = null;
                }
            });

            let totalPeriods = 0;
            for (let subject in counts) {
                totalPeriods += counts[subject];
            }

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>${sectionName.toUpperCase()}-${totalPeriods}</th>
                            ${COLUMNS.slice(1).map(day => `<th>${day}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            const timeSlotsKeys = Object.keys(classSchedule);
            if (timeSlotsKeys.length === 0) {
                html = `<p class="error-text">Section <strong>${sectionName.toUpperCase()}</strong> not found in the Master Table.</p>`;
            } else {
                timeSlotsKeys.forEach(time => {
                    const schedule = classSchedule[time];
                    if (schedule) {
                        html += `<tr><td class="time-cell">${time}</td>`;
                        COLUMNS.slice(1).forEach(day => {
                            const content = schedule[day];
                            const isFree = content.toUpperCase() === 'FREE' || content === '';
                            const cellClass = isFree ? 'free-cell' : 'class-cell';
                            html += `<td class="${cellClass}" style="background-color: ${isFree ? '#e0f7fa' : '#b2ebf2'}; color: #00796b; font-weight: ${isFree ? 'normal' : '600'};">${(content || 'Free').replace(/,/g, '<br>')}</td>`;
                        });
                        html += `</tr>`;
                    }
                });
            }

            html += `</tbody></table>`;

            let summaryHTML = '<table style="margin-top: 20px;"><thead><tr><th>Section</th><th>Subject</th><th>Periods</th></tr></thead><tbody>';
            for (let subject in counts) {
                summaryHTML += `<tr><td>${sectionName.toUpperCase()}</td><td>${subject}</td><td>${counts[subject]}</td></tr>`;
            }
            summaryHTML += '</tbody></table>';
            html += summaryHTML;

            return html;
        }

        function printCurrent() {
            const content = document.getElementById('timetableDisplay').innerHTML;
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Print Timetable</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        table { border-collapse: collapse; width: 100%; margin: 0 auto; }
                        th, td { border: 1px solid black; padding: 8px; text-align: center; }
                        th { background-color: #f0f0f0; font-weight: bold; }
                    </style>
                </head>
                <body>
                    ${content}
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        // --- Divider Drag Functionality ---

        function addDividerDrag() {
            const divider = document.querySelector('.divider');
            const leftPanel = document.querySelector('.left');
            const rightPanel = document.querySelector('.right');
            let isDragging = false;

            divider.addEventListener('mousedown', (e) => {
                isDragging = true;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none'; // Prevent text selection
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const totalWidth = window.innerWidth;
                const dividerWidth = divider.offsetWidth;
                const leftWidth = e.clientX - dividerWidth / 2;

                if (leftWidth > 200 && leftWidth < totalWidth - 200) { // Min widths
                    leftPanel.style.flex = `0 0 ${leftWidth}px`;
                    rightPanel.style.flex = '1 1 auto';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // --- Optimization Functionality ---

        let isOptimizing = false;
        let stopOptimization = false;
        let optimizationInterval = null;

        function toggleOptimization() {
            const btn = document.getElementById('optimizeBtn');
            if (isOptimizing) {
                stopOptimization = true;
                btn.textContent = 'Optimize';
                btn.className = 'btn-green';
                isOptimizing = false;
                if (optimizationInterval) {
                    clearInterval(optimizationInterval);
                    optimizationInterval = null;
                }
                // Update message display after a short delay to ensure optimization has stopped
                setTimeout(updateMessageDisplay, 100);
            } else {
                startOptimization();
            }
        }

        function startOptimization() {
            const btn = document.getElementById('optimizeBtn');
            isOptimizing = true;
            stopOptimization = false;
            btn.textContent = 'Stop Optimize';
            btn.className = 'btn-red';
            
            // Start optimization loop
            optimizationInterval = setInterval(() => {
                if (stopOptimization) {
                    toggleOptimization();
                    return;
                }
                
                const result = performOptimizationStep();
                if (result.complete) {
                    toggleOptimization();
                }
            }, 10); // Fast optimization loop
        }

        function performOptimizationStep() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            // Get current counts
            const currentClashes = findAllClashes().length;
            const currentDoubles = findAllDoubles();
            const currentGaps = findAllGaps();
            
            // Check if optimization is complete
            if (currentClashes === 0 && currentDoubles === 0 && currentGaps === 0) {
                return { complete: true };
            }

            // Find all editable cells (columns 2-6, which are indices 1-5) - excluding blanks
            const editableCells = [];
            rows.forEach((row, rowIndex) => {
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                // Skip time slot rows and lunch rows
                const firstCell = cells[0].value.trim();
                if ((firstCell.includes('-') && firstCell.includes(':')) || firstCell.toUpperCase() === 'LUNCH') {
                    return;
                }
                
                // Add cells from columns 2-6 (indices 1-5) that are not blank
                for (let colIndex = 1; colIndex <= 5; colIndex++) {
                    if (cells[colIndex] && cells[colIndex].value.trim() !== '') {
                        editableCells.push({
                            rowIndex,
                            colIndex,
                            cell: cells[colIndex]
                        });
                    }
                }
            });

            // Try random swaps
            if (editableCells.length >= 2) {
                const cell1 = editableCells[Math.floor(Math.random() * editableCells.length)];
                const cell2 = editableCells[Math.floor(Math.random() * editableCells.length)];
                
                if (cell1 !== cell2) {
                    const swapResult = trySwap(cell1, cell2);
                    if (swapResult) {
                        // Update message display with current counts
                        updateMessageDisplay();
                    }
                }
            }
            
            return { complete: false };
        }

        function trySwap(cell1, cell2) {
            // Store original values
            const originalValue1 = cell1.cell.value;
            const originalValue2 = cell2.cell.value;
            
            // Don't swap if either cell is blank
            if (originalValue1.trim() === '' || originalValue2.trim() === '') {
                return false;
            }
            
            // Perform swap
            cell1.cell.value = originalValue2;
            cell2.cell.value = originalValue1;
            
            // Get counts after swap
            const newClashes = findAllClashes().length;
            const newDoubles = findAllDoubles();
            const newGaps = findAllGaps();
            
            // Get original counts (before swap)
            // We need to temporarily restore to get original counts
            cell1.cell.value = originalValue1;
            cell2.cell.value = originalValue2;
            const originalClashes = findAllClashes().length;
            const originalDoubles = findAllDoubles();
            const originalGaps = findAllGaps();
            
            // Restore swapped values for evaluation
            cell1.cell.value = originalValue2;
            cell2.cell.value = originalValue1;
            
            // Apply optimization rules
            if (newClashes > originalClashes) {
                // Rule 1: Never increase clash count
                cell1.cell.value = originalValue1;
                cell2.cell.value = originalValue2;
                return false;
            } else if (newClashes < originalClashes) {
                // Rule 2: If swap decreases clash count, keep it
                return true;
            } else {
                // Clash count stays the same, check doubles
                if (newDoubles < originalDoubles) {
                    // Rule 3: If doubles count decreases, keep it
                    return true;
                } else if (newDoubles > originalDoubles) {
                    // Rule 4: If doubles count increases, reverse the swap
                    cell1.cell.value = originalValue1;
                    cell2.cell.value = originalValue2;
                    return false;
                } else {
                    // Doubles count stays the same, check gaps
                    if (newGaps > originalGaps) {
                        // Rule 5: If gap count increases, reverse the swap
                        cell1.cell.value = originalValue1;
                        cell2.cell.value = originalValue2;
                        return false;
                    } else {
                        // Rule 5: Otherwise keep the swap
                        return true;
                    }
                }
            }
        }

        function updateMessageDisplay() {
            const clashes = findAllClashes().length;
            const doubles = findAllDoubles();
            const gaps = findAllGaps();
            document.getElementById('messageDiv').textContent = 'File : ' + currentFileName + ' [ Clashes ' + clashes + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
        }

        // --- Clash Removal Functionality ---

        let isRemovingClashes = false;
        let stopRemoval = false;
        let focusedCell = null;
        let lastFocusedEditableCell = null;
        let originalMessage = '';

        function removeClashes() {
            const btn = document.getElementById('removeClashesBtn');
            if (isRemovingClashes) {
                stopRemoval = true;
                return;
            }
            isRemovingClashes = true;
            stopRemoval = false;
            btn.textContent = 'Stop Removal';
            originalMessage = document.getElementById('messageDiv').textContent;
            focusedCell = lastFocusedEditableCell;
            
            // Show progress bar
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            if (progressContainer) progressContainer.style.display = 'block';
            if (progressText) progressText.style.display = 'block';
            if (progressBar) progressBar.style.width = '0%';
            
            const clashes = findAllClashes();
            const totalClashes = clashes.length;
            resolveClashes(clashes, 0, totalClashes, 0, 0);
        }

        function findAllClashes() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            const clashes = [];
            const timeSlots = [];
            let currentSlot = null;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    if (currentSlot) timeSlots.push(currentSlot);
                    currentSlot = {time: firstCell, sections: []};
                } else if (currentSlot && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const section = {section: firstCell, days: {}};
                    for (let j = 1; j < COLUMNS.length; j++) {
                        section.days[COLUMNS[j]] = cells[j].value.trim();
                    }
                    currentSlot.sections.push(section);
                }
            }
            if (currentSlot) timeSlots.push(currentSlot);

            const allTeachers = getAllTeacherCodes();
            allTeachers.forEach(teacher => {
                timeSlots.forEach(slot => {
                    COLUMNS.slice(1).forEach(day => {
                        let assignments = [];
                        slot.sections.forEach(section => {
                            const cellValue = section.days[day];
                            // Handle both comma-separated and <br>-separated entries
                            const parts = cellValue.split(/[,\n]/); // Split by comma or newline
                            parts.forEach(part => {
                                const trimmed = part.trim();
                                if (trimmed && trimmed.match(new RegExp(`\\(${teacher}\\)$`, 'i'))) {
                                    assignments.push(trimmed);
                                }
                            });
                        });
                        // Count as a clash if the teacher has more than one assignment in this time slot and day
                        if (assignments.length > 1) {
                            clashes.push({teacher, time: slot.time, day, count: assignments.length});
                        }
                    });
                });
            });
            return clashes;
        }

        function findAllDoubles() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            const timeSlots = [];
            let currentSlot = null;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    if (currentSlot) timeSlots.push(currentSlot);
                    currentSlot = {time: firstCell, sections: []};
                } else if (currentSlot && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const section = {section: firstCell, days: {}};
                    for (let j = 1; j < COLUMNS.length; j++) {
                        section.days[COLUMNS[j]] = cells[j].value.trim();
                    }
                    currentSlot.sections.push(section);
                }
            }
            if (currentSlot) timeSlots.push(currentSlot);

            let doublesCount = 0;
            const allTeachers = getAllTeacherCodes();
            allTeachers.forEach(teacher => {
                COLUMNS.slice(1).forEach(day => {
                    const dayAssignments = {};
                    timeSlots.forEach(slot => {
                        slot.sections.forEach(section => {
                            const cellValue = section.days[day];
                            const parts = cellValue.split(',');
                            parts.forEach(part => {
                                if (part.trim().match(new RegExp(`\\(${teacher}\\)`, 'i'))) {
                                    if (!dayAssignments[section.section]) dayAssignments[section.section] = 0;
                                    dayAssignments[section.section]++;
                                }
                            });
                        });
                    });
                    Object.values(dayAssignments).forEach(count => {
                        if (count > 1) doublesCount++;
                    });
                });
            });
            return doublesCount;
        }

        function findAllGaps() {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            const timeSlots = [];
            let currentSlot = null;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    if (currentSlot) timeSlots.push(currentSlot);
                    currentSlot = {time: firstCell, sections: []};
                } else if (currentSlot && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const section = {section: firstCell, days: {}};
                    for (let j = 1; j < COLUMNS.length; j++) {
                        section.days[COLUMNS[j]] = cells[j].value.trim();
                    }
                    currentSlot.sections.push(section);
                }
            }
            if (currentSlot) timeSlots.push(currentSlot);

            // Filter out time slots where all days are 'Free' for all teachers
            const allTeachers = getAllTeacherCodes();
            const filteredTimeSlots = timeSlots.filter(slot => {
                return COLUMNS.slice(1).some(day => {
                    return slot.sections.some(section => {
                        const cellValue = section.days[day];
                        const parts = cellValue.split(',');
                        return parts.some(part => {
                            return allTeachers.some(teacher => part.trim().match(new RegExp(`\\(${teacher}\\)`, 'i')));
                        });
                    });
                });
            });

            let gapCount = 0;
            allTeachers.forEach(teacher => {
                COLUMNS.slice(1).forEach(day => {
                    const dayPeriods = [];
                    filteredTimeSlots.forEach(slot => {
                        let isFree = true;
                        slot.sections.forEach(section => {
                            const cellValue = section.days[day];
                            const parts = cellValue.split(',');
                            parts.forEach(part => {
                                if (part.trim().match(new RegExp(`\\(${teacher}\\)`, 'i'))) {
                                    isFree = false;
                                }
                            });
                        });
                        dayPeriods.push(isFree ? 'Free' : 'Busy');
                    });

                    let firstBusy = -1;
                    let lastBusy = -1;
                    for (let i = 0; i < dayPeriods.length; i++) {
                        if (dayPeriods[i] === 'Busy') {
                            if (firstBusy === -1) firstBusy = i;
                            lastBusy = i;
                        }
                    }

                    if (firstBusy !== -1 && lastBusy !== -1) {
                        for (let i = firstBusy + 1; i < lastBusy; i++) {
                            if (dayPeriods[i] === 'Free') gapCount++;
                        }
                    }
                });
            });
            return gapCount;
        }

        function resolveClashes(clashes, index, totalClashes, removed, attempt = 0) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');

            // Update progress bar
            let progress = 0;
            if (totalClashes > 0) {
                progress = ((attempt * totalClashes + index) / (10 * totalClashes)) * 100;
            }
            if (progressBar) progressBar.style.width = Math.min(progress, 100) + '%';
            if (progressText) progressText.textContent = `Removing clashes... (Attempt ${attempt + 1}/10)`;

            if (attempt > 9) { // Maximum 10 attempts
                isRemovingClashes = false;
                document.getElementById('removeClashesBtn').textContent = 'Remove Clashes';
                document.getElementById('messageDiv').textContent = 'Attempted clash removal (10 attempts)';
                // Hide progress bar
                if (progressContainer) progressContainer.style.display = 'none';
                if (progressText) progressText.style.display = 'none';
                setTimeout(() => {
                    const clashes = findAllClashes();
                    const doubles = findAllDoubles();
                    const gaps = findAllGaps();
                    document.getElementById('messageDiv').textContent = 'File : ' + currentFileName + ' [ Clashes ' + clashes.length + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
                }, 5000);
                if (focusedCell) {
                    focusedCell.focus();
                }
                return;
            }
            if (index >= clashes.length || stopRemoval) {
                const currentClashes = findAllClashes();
                if (currentClashes.length > 0 && attempt < 9) {
                    // Try again with new clashes found
                    console.log(`Attempt ${attempt + 1}: Found ${currentClashes.length} clashes, retrying...`);
                    resolveClashes(currentClashes, 0, currentClashes.length, removed, attempt + 1);
                    return;
                }
                // No more clashes or max attempts reached
                isRemovingClashes = false;
                document.getElementById('removeClashesBtn').textContent = 'Remove Clashes';
                const finalClashes = findAllClashes();
                if (finalClashes.length === 0) {
                    document.getElementById('messageDiv').textContent = 'All clashes resolved in ' + (attempt + 1) + ' attempt(s)!';
                } else {
                    document.getElementById('messageDiv').textContent = 'Completed with ' + finalClashes.length + ' remaining clashes after ' + (attempt + 1) + ' attempt(s)';
                }
                // Hide progress bar
                if (progressContainer) progressContainer.style.display = 'none';
                if (progressText) progressText.style.display = 'none';
                setTimeout(() => {
                    const clashes = findAllClashes();
                    const doubles = findAllDoubles();
                    const gaps = findAllGaps();
                    document.getElementById('messageDiv').textContent = 'File : ' + currentFileName + ' [ Clashes ' + clashes.length + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
                }, 5000);
                if (focusedCell) {
                    focusedCell.focus();
                }
                return;
            }
            const clash = clashes[index];
            const resolved = tryResolveClash(clash);
            if (resolved) {
                removed++;
                // Update counts in MessageDiv when a clash is removed
                const currentClashes = findAllClashes();
                const doubles = findAllDoubles();
                const gaps = findAllGaps();
                document.getElementById('messageDiv').textContent = 'File : ' + currentFileName + ' [ Clashes ' + currentClashes.length + ' | Doubles ' + doubles + ' | Gaps ' + gaps + ' ]';
            }
            setTimeout(() => resolveClashes(clashes, index + 1, totalClashes, removed, attempt), 0);
        }

        // Improved exchange cells logic - simple and safe version
        function tryExchangeCells(row1, col1, row2, col2, targetClash) {
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            if (row1 >= rows.length || row2 >= rows.length) return false;
            
            const cells1 = Array.from(rows[row1].querySelectorAll('.editable-cell'));
            const cells2 = Array.from(rows[row2].querySelectorAll('.editable-cell'));
            
            const o1 = cells1[col1].value;
            const o2 = cells2[col2].value;
            
            // Don't swap if either is blank
            if (o1.trim() === '' || o2.trim() === '') return false;
            
            // Count clashes BEFORE swap
            const clashCountBefore = findAllClashes().length;
            
            // Perform swap
            cells1[col1].value = o2;
            cells2[col2].value = o1;
            
            // Count clashes AFTER swap
            const clashCountAfter = findAllClashes().length;
            
            // ONLY keep swap if clashes DECREASED strictly
            if (clashCountAfter < clashCountBefore) {
                return true;
            }
            
            // Revert swap if clashes didn't decrease
            cells1[col1].value = o1;
            cells2[col2].value = o2;
            return false;
        }

        function tryResolveClash(clash) {
            const {teacher, time, day} = clash;
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            
            // 1. Find all cells involved in this specific clash
            const clashingCellLocations = [];
            let currentTime = null;
            
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    currentTime = firstCell;
                } else if (currentTime === time && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const dayIndex = COLUMNS.indexOf(day);
                    const cell = cells[dayIndex];
                    if (cell.value.match(new RegExp(`\\(${teacher}\\)`, 'i'))) {
                        clashingCellLocations.push({
                            rowIndex: i,
                            cellIndex: dayIndex,
                            section: firstCell
                        });
                    }
                }
            }

            if (clashingCellLocations.length < 2) return true; // Clash already resolved

            // 2. Try to swap clashing cells with other cells in same section (safe approach)
            for (const clashLocation of clashingCellLocations) {
                const { rowIndex: sourceRow, cellIndex: sourceCol, section } = clashLocation;
                const sourceCells = Array.from(rows[sourceRow].querySelectorAll('.editable-cell'));

                // Try swapping with all other cells in the same section
                for (let r = 0; r < rows.length; r++) {
                    const rCells = Array.from(rows[r].querySelectorAll('.editable-cell'));
                    const rFirst = rCells[0].value.trim();
                    
                    // Only consider cells in the same section
                    if (rFirst !== section) continue;
                    
                    for (let c = 1; c < COLUMNS.length; c++) {
                        if (r === sourceRow && c === sourceCol) continue; // Skip self
                        
                        const targetValue = rCells[c].value;
                        if (targetValue.trim() === '') continue; // Skip blank cells
                        
                        // Try exchange using conservative logic - only if clashes decrease
                        if (tryExchangeCells(sourceRow, sourceCol, r, c, clash)) {
                            // Check if clash is resolved
                            if (!hasClash(clash)) {
                                return true; // Success
                            }
                        }
                    }
                }
            }

            return false; // Could not resolve
        }

        function hasClash(clash) {
            const {teacher, time, day} = clash;
            const masterTableBody = document.querySelector('#masterTable tbody');
            const rows = Array.from(masterTableBody.querySelectorAll('tr'));
            let count = 0;
            let currentTime = null;
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('.editable-cell'));
                const firstCell = cells[0].value.trim();

                if (firstCell.includes('-') && firstCell.includes(':')) {
                    currentTime = firstCell;
                } else if (currentTime === time && firstCell !== '' && firstCell.toUpperCase() !== 'LUNCH') {
                    const cellValue = cells[COLUMNS.indexOf(day)].value.trim();
                    const parts = cellValue.split(',');
                    parts.forEach(part => {
                        if (part.trim().match(new RegExp(`\\(${teacher}\\)`, 'i'))) {
                            count++;
                        }
                    });
                }
            }
            return count > 1;
        }
    </script>
</body>
</html>
