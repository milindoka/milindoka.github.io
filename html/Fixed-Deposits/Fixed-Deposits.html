<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fixed Deposit Manager</title>
  <style>
    /* Ensure footer and SUM button are above the absolutely positioned list-items */
    #data-table tfoot { position: relative; z-index: 1000; }
    #update-totals-btn { position: relative; z-index: 1001; cursor: pointer; }

    /* keep list items below footer */
    .list-item { z-index: 1; }
    :root {
      --item-height: 30px;
      --animation-duration: 0.5s;
    }
    .list-container {
      position: relative;
      height: calc(var(--item-height) * 7);
    }
    table {margin-left: auto;margin-right: auto;}
    .list-item {
      position: absolute;
      height: var(--item-height);
      transition: all var(--animation-duration) ease;
      display: flex;
      align-items: center;
      justify-content: flex-start; /* Align items to start */
      font-size: 16px;
    }
    .list-item td, .header-row th {
      height: 20px;
      empty-cells: show; 
      padding: 0 20px;
      text-align: center;
      margin-right: 2px !important;
      background-color: rgb(223, 188, 170) !important; /* Ensure background color is applied */
      border: 3px solid rgba(219, 210, 210, 0.552); /* Add a border to make cells visible */
    }
    .list-item td {
      empty-cells: show !important; /* This may not be necessary */
      text-align: left;
      background-color: aqua !important; /* Ensure background color is applied */
      overflow: hidden;
      white-space: nowrap;
    }
    /* Ensure that all cells have a minimum height */
    .list-item td {
      height: 20px; /* Ensures consistent height */
      border-spacing: 20px;
    }
    .button-container {
      display: flex;
      justify-content: center; /* Center the buttons horizontally */
      margin: 20px 0; /* Add some margin for spacing */
    }
    .button-container button {
      margin: 0 10px; /* Add space between buttons */
    }
    /* Slider styles */
    .slider-container {
      display: flex;
      justify-content: center;
      margin: 20px 0; /* Add some margin for spacing */
    }
    input[type="range"] {
      width: 50%; /* Adjust the width of the slider */
    }
    /* slider styles end */
    /* Totals section styles */
    .totals-container {
      display: flex;
      justify-content: center;
      margin: 20px 0;
      gap: 20px;
      align-items: center;
    }
    .total-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background-color: #f0f0f0;
      border: 2px solid #ccc;
      border-radius: 5px;
      min-width: 150px;
    }
    .total-label {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 14px;
    }
    .total-value {
      font-size: 16px;
      color: #333;
      font-weight: bold;
    }
    #update-totals-btn {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    #update-totals-btn:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div id="list-container" class="list-container">
    <table id="data-table">
      <thead>
        <tr class="header-row"></tr>
      </thead>
      <tbody id="list-body"></tbody>
      <tfoot>
        <tr>
          <td></td>
          <td style="text-align:center;">
            <!-- SUM button placed in second column of table footer -->
            <button id="update-totals-btn" style="padding:6px 10px; font-size:12px;">SUM</button>
          </td>
          <td id="table-maturity-total" style="font-weight:bold; text-align:right;">0</td>
          <td id="table-principal-total" style="font-weight:bold; text-align:right;">0</td>
          <td colspan="5"></td>
        </tr>
      </tfoot>
    </table>
  </div>
  
  </div>

  <!-- Search UI (moved here): placed above button row, immediately after Update Totals -->
  <div style="text-align:center; margin:10px 0;">
    <div class="search-wrapper" style="display:inline-flex;align-items:center;gap:6px;">
      <input id="search-input" type="search" placeholder="Search..." style="padding:6px 8px;font-size:14px;width:240px;border:1px solid #888;border-radius:4px;" />
      <button id="search-btn" title="Search" style="padding:6px 8px;font-size:14px;cursor:pointer;">üîç</button>
    </div>
  </div>

  <!-- Button Container -->
  <div class="button-container">
    <button id="animate-btn">Animate Up</button>
    <button id="animate-down-btn">Animate Down</button>
    <button id="insert-below-btn">Insert Below</button>
    <button id="insert-above-btn">Insert Above</button>
    <button id="delete-row-btn">Delete Row</button>
    <button id="copy-upper-btn">Copy Upper</button>
    <button id="save-data-btn">Save Data</button>
    <button id="sort-btn">Sort</button>
    <button id="load-data-btn">Load Data</button>
    <button id="save-local-btn">SLS</button> <!-- Save to Local Storage -->
    <button id="load-local-btn">LLS</button> <!-- Load from Local Storage -->
    <button id="report-btn">Report</button>
    <button id="sample-data-btn">Sample Data</button> <!-- ADDED -->
    <button id="load-csv-btn">Load CSV</button> <!-- NEW -->
  </div>
  <div style="text-align:center; margin-bottom:12px;">
    <button id="accrued-btn">Accrued Interest</button>
  </div>
  <!-- Slider Container -->
  <div class="slider-container">
    <input type="range" id="slider" min="1" max="9" value="1" />
    <div id="slider-value" style="margin-left: 15px; min-width: 40px; display: inline-block; font-weight: bold;">25</div>
  </div>
  <script>
    // Report button click handler: classify records by FY of Maturity Date and show HTML report in new window
    document.getElementById('report-btn').addEventListener('click', function() {
      // Helpers
      function parseDateLocal(dateStr) {
        if (!dateStr || dateStr.trim() === '') return null;
        let d, m, y;
        if (dateStr.includes('/')) [d, m, y] = dateStr.split('/').map(x => parseInt(x, 10));
        else if (dateStr.includes('-')) [d, m, y] = dateStr.split('-').map(x => parseInt(x, 10));
        else { // try Date parse
          const dt = new Date(dateStr);
          if (isNaN(dt.getTime())) return null;
          return dt;
        }
        if (y < 100) y += 2000;
        return new Date(y, m - 1, d);
      }
      function yearsBetween(d1, d2) {
        return (d2 - d1) / (1000 * 60 * 60 * 24 * 365.2425);
      }
      function formatINR(num) { return num.toLocaleString('en-IN'); }

      // Build fyMap so:
      // - non-monthly deposits appear only in the FY of their maturity date
      // - monthly-paid deposits appear in every FY in which their life overlaps,
      //   with income calculated for that FY (yearly income earned during overlap)
      const fyMap = {}; // fyLabel -> array of entries { idx, row, income, isSimpleMonthly }

      items.forEach((row, idx) => {
        const maturityDate = parseDateLocal(row[0]);
        const maturityAmt = parseFloat(String(row[1] || '').replace(/[^\d.\-]/g, '')) || 0;
        const principal = parseFloat(String(row[2] || '').replace(/[^\d.\-]/g, '')) || 0;
        if (!maturityDate || principal === 0) return;
        const openingDate = parseDateLocal(row[3]);

        // read rate (col index 5) normalized to decimal
        let rate = parseFloat((row[5] || '').toString().trim());
        rate = (!isNaN(rate) ? (rate > 1 ? rate / 100 : rate) : 0);

        // estimate term years and derive rate if missing
        let termYears = 1;
        if (openingDate) termYears = Math.max(0.0001, yearsBetween(openingDate, maturityDate));
        else if (rate && principal > 0 && maturityAmt > 0) termYears = Math.max(0.0001, Math.log(maturityAmt / principal) / Math.log(1 + rate));
        if (!rate && principal > 0 && maturityAmt > 0 && termYears > 0) {
          rate = Math.pow(maturityAmt / principal, 1 / termYears) - 1;
        }

        const lifeStart = openingDate || new Date(maturityDate.getTime() - termYears * 365.2425 * 24 * 3600 * 1000);
        const lifeEnd = maturityDate;

        const isSimpleMonthly = Math.abs(maturityAmt - principal) < 0.01;

        if (!isSimpleMonthly) {
          // Non-monthly: include only in FY of maturity date
          const mo = maturityDate.getMonth() + 1;
          const yr = maturityDate.getFullYear();
          const fyLabel = (mo >= 4) ? `FY-${String(yr).slice(-2)}-${String(yr + 1).slice(-2)}` : `FY-${String(yr - 1).slice(-2)}-${String(yr).slice(-2)}`;
          const income = maturityAmt - principal;
          if (!fyMap[fyLabel]) fyMap[fyLabel] = [];
          fyMap[fyLabel].push({ idx: idx + 1, row, income, isSimpleMonthly: false, principal, maturityAmt });
          return;
        }

        // Monthly-paid deposit: include in every FY overlapping lifeStart..lifeEnd
        // compute FY range
        const startFyYear = (lifeStart.getMonth() + 1) >= 4 ? lifeStart.getFullYear() : lifeStart.getFullYear() - 1;
        const endFyYear = (lifeEnd.getMonth() + 1) >= 4 ? lifeEnd.getFullYear() : lifeEnd.getFullYear() - 1;
        for (let fyStartYear = startFyYear; fyStartYear <= endFyYear; fyStartYear++) {
          const fyStart = new Date(fyStartYear, 3, 1); // 1 Apr
          const fyEnd = new Date(fyStartYear + 1, 2, 31, 23, 59, 59, 999); // 31 Mar next year
          const overlapStart = (lifeStart > fyStart) ? lifeStart : fyStart;
          const overlapEnd = (lifeEnd < fyEnd) ? lifeEnd : fyEnd;
          if (overlapEnd < overlapStart) continue;
          const msPerDay = 1000 * 60 * 60 * 24;
          const overlapDays = Math.round((overlapEnd.getTime() - overlapStart.getTime()) / msPerDay) + 1;
          const income = principal * rate * (overlapDays / 365.2425); // yearly-pro-rated income for overlap
          const fyLabel = `FY-${String(fyStartYear).slice(-2)}-${String(fyStartYear + 1).slice(-2)}`;
          if (!fyMap[fyLabel]) fyMap[fyLabel] = [];
          fyMap[fyLabel].push({ idx: idx + 1, row, income, isSimpleMonthly: true, principal, maturityAmt });
        }
      });

      // Build report HTML
      let reportHtml = `<!DOCTYPE html><html lang="en"><head><meta charset='UTF-8'><title>FD Report by Financial Year</title><style>
        body{font-family:Arial;margin:20px} h2{color:#2a4d7a} table{border-collapse:collapse;margin-bottom:30px;width:100%} th,td{border:1px solid #888;padding:6px 10px;text-align:center} th{background:#e0e7ef} .right{text-align:right}
      </style></head><body><h1>Fixed Deposit Report by Financial Year (Maturity Date)</h1>`;

      Object.keys(fyMap).sort().forEach(fy => {
        const entries = fyMap[fy];
        reportHtml += `<div class='fy-section'><h2>${fy}</h2><table><thead><tr><th>Sr</th>`;
        for (let i = 0; i < headerArray.length - 1; ++i) reportHtml += `<th>${headerArray[i + 1]}</th>`;
        reportHtml += `<th>Income (‚Çπ)</th></tr></thead><tbody>`;

        const personIncome = {};
        const personPrincipal = {};

        entries.forEach(entry => {
          const incomeForDisplay = entry.income || 0;
          const name = (entry.row[entry.row.length - 1] || '').toString().trim() || 'Unknown';
          personIncome[name] = (personIncome[name] || 0) + incomeForDisplay;
          personPrincipal[name] = (personPrincipal[name] || 0) + (entry.principal || 0);

          reportHtml += `<tr><td>${entry.idx}</td>`;
          for (let i = 0; i < entry.row.length; ++i) reportHtml += `<td>${entry.row[i]}</td>`;
          reportHtml += `<td style="text-align:right">${entry.isSimpleMonthly ? ('‚Çπ ' + formatINR(Math.round(incomeForDisplay)) + ' (monthly-paid)') : '‚Çπ ' + formatINR(Math.round(incomeForDisplay))}</td></tr>`;
        });

        reportHtml += `</tbody></table>`;

        // Per-person summary table: Name | Total Principal | Total Income | Total Maturity
        reportHtml += `<div style="margin-top:8px;"><strong>Income by Individual for ${fy}:</strong>`;
        reportHtml += `<table><thead><tr><th>Name</th><th style="text-align:right">Total Principal (‚Çπ)</th><th style="text-align:right">Total Income (‚Çπ)</th><th style="text-align:right">Total Maturity (‚Çπ)</th></tr></thead><tbody>`;
        let totalPrincipalFY = 0, totalIncomeFY = 0, totalMaturityFY = 0;
        Object.keys(personIncome).sort((a, b) => (personIncome[b] - personIncome[a])).forEach(name => {
          const p = Math.round(personPrincipal[name] || 0);
          const inc = Math.round(personIncome[name] || 0);
          const mat = p + inc;
          totalPrincipalFY += p;
          totalIncomeFY += inc;
          totalMaturityFY += mat;
          reportHtml += `<tr><td style="text-align:left;padding-left:10px">${name}</td><td style="text-align:right">‚Çπ ${formatINR(p)}</td><td style="text-align:right">‚Çπ ${formatINR(inc)}</td><td style="text-align:right">‚Çπ ${formatINR(mat)}</td></tr>`;
        });
        // totals row
        reportHtml += `<tr style="font-weight:bold;background:#e0e7ef"><td style="text-align:left;padding-left:10px">Total</td><td style="text-align:right">‚Çπ ${formatINR(totalPrincipalFY)}</td><td style="text-align:right">‚Çπ ${formatINR(totalIncomeFY)}</td><td style="text-align:right">‚Çπ ${formatINR(totalMaturityFY)}</td></tr>`;
        reportHtml += `</tbody></table></div>`;

        reportHtml += `</div>`;
      });

      reportHtml += `</body></html>`;

      const reportWin = window.open('', '_blank');
      if (reportWin) { reportWin.document.write(reportHtml); reportWin.document.close(); } else { alert('Unable to open report window. Please allow pop-ups.'); }
    });
    
    
    const listContainer = document.getElementById('list-container');
    const slider = document.getElementById('slider');
    const sliderValueDiv = document.getElementById('slider-value');
    const animateBtn = document.getElementById('animate-btn');
    const animateDownBtn = document.getElementById('animate-down-btn');
    const insertBelowBtn = document.getElementById('insert-below-btn');
    const insertAboveBtn = document.getElementById('insert-above-btn');
    const deleteRowBtn = document.getElementById('delete-row-btn');
    const listBody = document.getElementById('list-body');
    const headerRow = document.querySelector('.header-row');
    const itemHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--item-height'));
    const columnWidths = [20, 100, 110, 110, 100, 200, 70, 70, 50]; // Adjust widths as needed
    const MaxChars = [-1, 8, 7, 7, 8, 20, 8, 8, 8]; // Maximum characters for each column
    const headerArray = ['Sr', 'Maturity Date', 'Maturity Amt', 'Principal Amt', 'Opening Date', 'FD Account No', 'Interest', 'Banks', 'Name']; // Header array    
    const numColumns = columnWidths.length;
    const items = Array.from({length: 9}, () => Array.from({length: numColumns - 1}, () => ''));
    let currentIndex = items.length - 3;
    let isAnimating = false;

    // --- search state for cycling through matches ---
    let _searchLastQuery = '';
    let _searchMatches = []; // array of matched row indices
    let _searchPos = -1;
    let _searchItemsVersion = 0; // increment when items change to invalidate cache
    function createHeaderRow() {
      headerArray.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
      });
    }
    // Update slider value display
    slider.addEventListener('input', function() {
      sliderValueDiv.textContent = slider.value;
    });
    function createListItems() {

   // Add a few non-animated spacer rows so tbody gets height and tfoot sits after data
      const spacerCount = 5;
      for (let s = 0; s < spacerCount; s++) {
        const spacer = document.createElement('tr');
        spacer.className = 'spacer-row';
        // create empty cells equal to number of columns so widths align
        spacer.innerHTML = Array.from({ length: numColumns }).map(() => '<td>&nbsp;</td>').join('');
        // give the spacer the same height as an item so footer is shifted down
        spacer.style.height = `${itemHeight}px`;
        listBody.appendChild(spacer);
      }


      for (let i = 0; i < 7; i++) {
        const item = document.createElement('tr');
        item.className = 'list-item';
        item.style.top = `${i * itemHeight}px`;
        item.style.opacity = i === 2 || i === 4 ? 0.5 : i === 3 ? 1 : i === 1 || i === 5 ? 0.25 : 0;
        const serialCell = document.createElement('td');
        serialCell.textContent = i + 1; // Serial numbers start from 1
        item.appendChild(serialCell);
        // capture row position for closures so handlers update correct model row
        const rowPos = i;
        for (let j = 0; j < numColumns - 1; j++) {
          const cell = document.createElement('td');
          if (i === 3) {
            cell.setAttribute('contenteditable', 'true');
            cell.addEventListener('keypress', function(e) {
              const maxLength = MaxChars[j + 1];
              if (this.textContent.length >= maxLength) {
                e.preventDefault();
                return false;
              }
            });
            cell.addEventListener('paste', function(e) {
              e.preventDefault();
              const text = e.clipboardData.getData('text/plain');
              const maxLength = MaxChars[j + 1];
              const availableSpace = maxLength - this.textContent.length;
              if (availableSpace > 0) {
                document.execCommand('insertText', false, text.substr(0, availableSpace));
              }
            });
            // Persist as user types
            cell.addEventListener('input', (event) => {
              // compute which logical row in items[] this visual row corresponds to
              const rowOffset = (currentIndex + rowPos) % items.length;
              items[rowOffset][j] = event.target.textContent;
            });
            cell.addEventListener('blur', (event) => {
              const rowOffset = (currentIndex + rowPos) % items.length;
              items[rowOffset][j] = event.target.textContent;
            });
          } else {
            cell.setAttribute('contenteditable', 'false');
          }
          item.appendChild(cell);
        }
        listBody.appendChild(item);
      }
      updateListItems();
      setTimeout(() => {
        const centerRow = listBody.querySelectorAll('.list-item')[3];
        const firstCell = centerRow.querySelector('td:nth-child(2)');
        if (firstCell) {
          firstCell.focus();
          loadDataFromLocalStorage();
        }
      }, 0);
    }
    function setColumnWidths() {
      const cells = listBody.querySelectorAll('td');
      cells.forEach((cell, index) => {
        const columnIndex = index % numColumns;
        cell.style.width = `${columnWidths[columnIndex]}px`;
      });
      const headerCells = headerRow.querySelectorAll('th');
      headerCells.forEach((cell, index) => {
        cell.style.width = `${columnWidths[index]}px`;
      });
    }
    ////////////////////////////////
    function updateListItems() {
      const listItems = document.querySelectorAll('.list-item');
      listItems.forEach((item, index) => {
        const cells = item.getElementsByTagName('td');
        const rowData = items[(currentIndex + index) % items.length];
        cells[0].textContent = (currentIndex + index) % (items.length) + 1; // Update serial number
        for (let i = 0; i < cells.length - 1; i++) {
          cells[i + 1].textContent = rowData[i] || ''; // Set to empty string if no data
        }
      });
      setColumnWidths();
    }
    /////////////////////////////////
    // --- preserved focus storage for keyboard-triggered animations ---
    window._preservedFocus = null;

    function animateList() {
      if (isAnimating) return;
      isAnimating = true;
      // Use preserved focus info if provided (keyboard case), otherwise read activeElement
      let focusedCellIndex = -1;
      let focusedRowIndex = -1;
      if (window._preservedFocus) {
        focusedCellIndex = window._preservedFocus.cellIndex;
        focusedRowIndex = window._preservedFocus.rowIndex;
        // commit text saved earlier
        const rowOffset = (currentIndex + focusedRowIndex) % items.length;
        items[rowOffset][focusedCellIndex - 1] = window._preservedFocus.text;
        window._preservedFocus = null;
      } else {
        const activeElement = document.activeElement;
        if (activeElement && activeElement.tagName === 'TD') {
          const currentRow = activeElement.parentElement;
          const cells = currentRow.getElementsByTagName('td');
          focusedCellIndex = Array.prototype.indexOf.call(cells, activeElement);
          focusedRowIndex = Array.prototype.indexOf.call(listBody.children, currentRow);
          const rowOffset = (currentIndex + focusedRowIndex) % items.length;
          items[rowOffset][focusedCellIndex - 1] = activeElement.textContent;
        } else {
          const centerRow = listBody.querySelectorAll('.list-item')[3];
          const firstCell = centerRow.firstChild;
          if (firstCell) firstCell.focus();
          focusedCellIndex = 0;
          focusedRowIndex = 3;
        }
      }
      const listItems = document.querySelectorAll('.list-item');
      listItems.forEach((item, index) => {
        item.style.top = `${(index - 1) * itemHeight}px`;
        item.style.opacity = index === 4 ? 1 : index === 3 || index === 5 ? 0.5 : index === 2 || index === 6 ? 0.25 : 0;
      });
      setTimeout(() => {
        currentIndex = (currentIndex + 1) % items.length;
        updateListItems();
        listItems.forEach((item, index) => {
          item.style.transition = 'none';
          item.style.top = `${index * itemHeight}px`;
          item.style.opacity = index === 3 ? 1 : index === 2 || index === 4 ? 0.5 : index === 1 || index === 5 ? 0.25 : 0;
        });
        setTimeout(() => {
          listItems.forEach(item => item.style.transition = '');
          isAnimating = false;
          if (focusedCellIndex !== -1 && focusedRowIndex !== -1) {
            const newRow = listItems[3];
            const newCell = newRow.getElementsByTagName('td')[focusedCellIndex];
            if (newCell) newCell.focus();
          }
          // Update slider to reflect current center record
          if (typeof slider !== 'undefined') {
            slider.max = items.length;
            const centerSerial = ((currentIndex + 3) % items.length) + 1;
            slider.value = centerSerial;
            if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
          }
        }, 50);
      }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-duration')) * 1000);
    }

    function animateListDown() {
      if (isAnimating) return;
      isAnimating = true;
      // Use preserved focus info if provided (keyboard case), otherwise read activeElement
      let focusedCellIndex = -1;
      let focusedRowIndex = -1;
      if (window._preservedFocus) {
        focusedCellIndex = window._preservedFocus.cellIndex;
        focusedRowIndex = window._preservedFocus.rowIndex;
        const rowOffset = (currentIndex + focusedRowIndex) % items.length;
        items[rowOffset][focusedCellIndex - 1] = window._preservedFocus.text;
        window._preservedFocus = null;
      } else {
        const activeElement = document.activeElement;
        if (activeElement && activeElement.tagName === 'TD') {
          const currentRow = activeElement.parentElement;
          const cells = currentRow.getElementsByTagName('td');
          focusedCellIndex = Array.prototype.indexOf.call(cells, activeElement);
          focusedRowIndex = Array.prototype.indexOf.call(listBody.children, currentRow);
          const rowOffset = (currentIndex + focusedRowIndex) % items.length;
          items[rowOffset][focusedCellIndex - 1] = activeElement.textContent;
        } else {
          const centerRow = listBody.querySelectorAll('.list-item')[3];
          const firstCell = centerRow.firstChild;
          if (firstCell) firstCell.focus();
          focusedCellIndex = 0;
          focusedRowIndex = 3;
        }
      }
      const listItems = document.querySelectorAll('.list-item');
      listItems.forEach((item, index) => {
        item.style.top = `${(index + 1) * itemHeight}px`;
        item.style.opacity = index === 2 ? 1 : index === 3 || index === 1 ? 0.5 : index === 4 || index === 0 ? 0.25 : 0;
      });
      setTimeout(() => {
        currentIndex = (currentIndex - 1 + items.length) % items.length;
        updateListItems();
        listItems.forEach((item, index) => {
          item.style.transition = 'none';
          item.style.top = `${index * itemHeight}px`;
          item.style.opacity = index === 3 ? 1 : index === 2 || index === 4 ? 0.5 : index === 1 || index === 5 ? 0.25 : 0;
        });
        setTimeout(() => {
          listItems.forEach(item => item.style.transition = '');
          isAnimating = false;
          if (focusedCellIndex !== -1 && focusedRowIndex !== -1) {
            const newRow = listItems[3];
            const newCell = newRow.getElementsByTagName('td')[focusedCellIndex];
            if (newCell) newCell.focus();
          }
          // Update slider to reflect current center record
          if (typeof slider !== 'undefined') {
            slider.max = items.length;
            const centerSerial = ((currentIndex + 3) % items.length) + 1;
            slider.value = centerSerial;
            if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
          }
        }, 50);
      }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-duration')) * 1000);
    }

    // Replace blur-based commit in keydown: save focus info then call animate functions
    document.addEventListener('keydown', (event) => {
      const activeElement = document.activeElement;
      if (activeElement && activeElement.tagName === 'TD') {
        const currentRow = activeElement.parentElement;
        const cells = currentRow.getElementsByTagName('td');
        const cellIndex = Array.prototype.indexOf.call(cells, activeElement);
        const focusedRowIndex = Array.prototype.indexOf.call(listBody.children, currentRow);
        if (event.key === 'Enter' || event.key === 'ArrowDown') {
          // save edited text and focus coordinates, do NOT blur (preserve keyboard editing UX)
          window._preservedFocus = { cellIndex: cellIndex, rowIndex: focusedRowIndex, text: activeElement.textContent };
          animateList();
          event.preventDefault();
        } else if (event.key === 'ArrowUp') {
          window._preservedFocus = { cellIndex: cellIndex, rowIndex: focusedRowIndex, text: activeElement.textContent };
          animateListDown();
          event.preventDefault();
        } else if (event.key === 'ArrowRight') {
          if (cellIndex < cells.length - 1) {
            cells[cellIndex + 1].focus();
          } else {
            cells[1].focus();
          }
          event.preventDefault();
        } else if (event.key === 'ArrowLeft') {
          if (cellIndex > 1) {
            cells[cellIndex - 1].focus();
          } else {
            cells[cells.length - 1].focus();
          }
          event.preventDefault();
        }
      }
    });
    function deleteRow() {
      if (items.length > 7) {
        const centerRowIndex = (currentIndex + 3) % items.length;
        items.splice(centerRowIndex, 1);
        // Ensure currentIndex stays valid
        currentIndex = Math.min(currentIndex, items.length - 1);
        updateListItems();
        // Update slider range and position to reflect deletion
        if (typeof slider !== 'undefined') {
          slider.max = items.length;
          // set slider to the new center record (1-based)
          const centerSerial = ((currentIndex + 3) % items.length) + 1;
          slider.value = Math.min(Math.max(1, centerSerial), items.length);
          if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
        }
      } else {
        alert("Cannot delete row. Minimum number of rows (7) reached.");
      }
    }
    const copyUpperBtn = document.getElementById('copy-upper-btn');
    function copyUpperRow() {
      const centerRowIndex = (currentIndex + 3) % items.length;
      const upperRowIndex = (currentIndex + 2) % items.length;
      for (let i = 0; i < numColumns - 1; i++) {
        items[centerRowIndex][i] = items[upperRowIndex][i];
      }
      updateListItems();
      const centerRow = listBody.querySelectorAll('.list-item')[3];
      const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
      if (firstEditableCell) {
        firstEditableCell.focus();
      }
    }

    // Insert a blank row below the center row
    function insertRowBelow() {
      const centerRowIndex = (currentIndex + 3) % items.length;
      const newRow = Array.from({ length: numColumns - 1 }, () => '');
      items.splice(centerRowIndex + 1, 0, newRow);
      // Keep currentIndex valid
      if (currentIndex > items.length - 1) currentIndex = items.length - 1;
      // Invalidate search cache
      _searchItemsVersion = items.length;
      _searchMatches = [];
      _searchPos = -1;
      updateListItems();
      // Update slider range and position
      if (typeof slider !== 'undefined') {
        slider.max = items.length;
        const centerSerial = ((currentIndex + 3) % items.length) + 1;
        slider.value = Math.min(Math.max(1, centerSerial), items.length);
        if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
      }
      // Focus editable cell in center row
      const centerRow = listBody.querySelectorAll('.list-item')[3];
      if (centerRow) {
        const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
        if (firstEditableCell) firstEditableCell.focus();
      }
    }

    // Insert a blank row above the center row
    function insertRowAbove() {
      const centerRowIndex = (currentIndex + 3) % items.length;
      const newRow = Array.from({ length: numColumns - 1 }, () => '');
      items.splice(centerRowIndex, 0, newRow);
      // After inserting above, make the inserted row the new center by advancing currentIndex
      currentIndex = (currentIndex + 1) % items.length;
      // Invalidate search cache
      _searchItemsVersion = items.length;
      _searchMatches = [];
      _searchPos = -1;
      updateListItems();
      // Update slider range and position
      if (typeof slider !== 'undefined') {
        slider.max = items.length;
        const centerSerial = ((currentIndex + 3) % items.length) + 1;
        slider.value = Math.min(Math.max(1, centerSerial), items.length);
        if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
      }
      // Focus editable cell in center row
      const centerRow = listBody.querySelectorAll('.list-item')[3];
      if (centerRow) {
        const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
        if (firstEditableCell) firstEditableCell.focus();
      }
    }
    /////////////////////////////////////////////
    // Jump button and its handler removed ‚Äî slider is used for jump now
    /////////////////////////////////////////////
    copyUpperBtn.addEventListener('click', copyUpperRow);
    createHeaderRow(); // Create the header row
    createListItems();
    animateBtn.addEventListener('mousedown', animateList);
    animateDownBtn.addEventListener('mousedown', animateListDown);
    insertBelowBtn.addEventListener('click', insertRowBelow);
    insertAboveBtn.addEventListener('click', insertRowAbove);
    deleteRowBtn.addEventListener('click', deleteRow);
    // Initialize slider value display
    sliderValueDiv.textContent = slider.value;
  // Throttle for wheel->slider mapping
  let _lastWheelAt = 0;
  const _wheelThrottleMs = 80; // minimum ms between handled wheel events
    const saveDataBtn = document.getElementById('save-data-btn');
    saveDataBtn.addEventListener('click', saveDataAsHTML);
    function saveDataAsHTML() {
      const now = new Date();
      const dd = String(now.getDate()).padStart(2, '0');
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const yy = String(now.getFullYear()).slice(-2);
      const filename = `FD-List-${dd}-${mm}-${yy}.html`;

      let htmlContent = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Saved Spreadsheet Data</title>
        <style>
          table { border-collapse: collapse; }
          th, td { border: 1px solid black; padding: 5px; }
          ${columnWidths.map((width, index) => `
            th:nth-child(${index + 1}), td:nth-child(${index + 1}) { width: ${width}px; }
          `).join('')}
        </style>
      </head>
      <body>
        <table>
          <thead>
            <tr>
              ${headerArray.map(header => `<th>${header}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
            ${items.map((row, index) => `
              <tr>
                <td>${index + 1}</td>
                ${row.map(cell => `<td>${cell}</td>`).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </body>
      </html>
      `;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }
    const loadDataBtn = document.getElementById('load-data-btn');
    loadDataBtn.addEventListener('click', loadDataFromHTML);
    function loadDataFromHTML() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.html';
      input.onchange = function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
          const content = e.target.result;
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const rows = doc.querySelectorAll('table tbody tr');
          items.length = 0; // Clear existing data
          rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            const rowData = Array.from(cells).slice(1).map(cell => cell.textContent);
            items.push(rowData);
          });
          // Set to first record and update display
          currentIndex = items.length - 3; // Set current index to the last row
          updateListItems();
          // Update slider range and value
          slider.max = items.length;
          slider.value = 1;
          sliderValueDiv.textContent = slider.value;
        };
        reader.readAsText(file);
      };
      input.click();
    }
    // Function to save data to local storage
    function saveDataToLocalStorage() {
      localStorage.setItem('fixedDepositData', JSON.stringify(items));
      alert('Data saved to local storage.');
    }
    // Function to load data from local storage
    function loadDataFromLocalStorage() {
      const data = localStorage.getItem('fixedDepositData');
      if (data) {
        const loadedItems = JSON.parse(data);
        items.length = 0; // Clear existing data
        loadedItems.forEach(row => {
          items.push(row);
        });
        currentIndex = items.length - 3; // Set current index to the last row
        updateListItems();
        // Update slider range and value
        slider.max = items.length;
        slider.value = 1;
        sliderValueDiv.textContent = slider.value;
        //alert('Data loaded from local storage.');
      } else {
        //alert('No data found in local storage.');
      }
    }
    // Add event listeners for the new buttons
    const saveLocalBtn = document.getElementById('save-local-btn');
    const loadLocalBtn = document.getElementById('load-local-btn');
    saveLocalBtn.addEventListener('click', saveDataToLocalStorage);
    loadLocalBtn.addEventListener('click', loadDataFromLocalStorage);
    
    // --- Load CSV button handler (fixed: trigger file picker) ---
    const loadCsvBtn = document.getElementById('load-csv-btn');
    loadCsvBtn.addEventListener('click', function() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv,text/csv';
      input.onchange = function (e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
          const text = evt.target.result;
          // Simple robust CSV parser (handles quotes and double quotes)
          function parseCSV(src) {
            const rows = [];
            let cur = [];
            let field = '';
            let inQuotes = false;
            for (let i = 0; i < src.length; i++) {
              const ch = src[i];
              const next = src[i+1];
              if (inQuotes) {
                if (ch === '"') {
                  if (next === '"') { field += '"'; i++; } else { inQuotes = false; }
                } else {
                  field += ch;
                }
              } else {
                if (ch === '"') {
                  inQuotes = true;
                } else if (ch === ',') {
                  cur.push(field); field = '';
                } else if (ch === '\r') {
                  // ignore
                } else if (ch === '\n') {
                  cur.push(field); rows.push(cur); cur = []; field = '';
                } else {
                  field += ch;
                }
              }
            }
            // push last
            if (field !== '' || cur.length > 0) { cur.push(field); rows.push(cur); }
            return rows;
          }

          const csvRows = parseCSV(text).filter(r => r.length > 0 && r.some(c => c.trim() !== ''));
          if (csvRows.length === 0) { alert('CSV empty or not parseable'); return; }

          // Attempt to detect header row mapping to app headers (exclude 'Sr')
          function normalize(s){ return (s||'').toString().toLowerCase().replace(/[^a-z0-9]/g,''); }
          const targetHeaders = headerArray.slice(1).map(h => normalize(h)); // expected columns (without Sr)
          let dataStart = 0;
          let mapping = null; // maps target index -> csv column index
          const firstRow = csvRows[0];
          // try header detection
          const firstNorm = firstRow.map(c => normalize(c));
          let hits = 0;
          const tryMap = targetHeaders.map(() => -1);
          firstNorm.forEach((fn, ci) => {
            targetHeaders.forEach((th, ti) => {
              if (fn === th || fn.indexOf(th) !== -1 || th.indexOf(fn) !== -1) {
                if (tryMap[ti] === -1) { tryMap[ti] = ci; hits++; }
              }
            });
          });
          // if at least 3 matches, accept header
          if (hits >= 3) { mapping = tryMap; dataStart = 1; }
          else {
            // no header: assume CSV columns already match expected order
            mapping = null;
            dataStart = 0;
          }

          // Build rows in app format: [Maturity Date, Maturity Amt, Principal Amt, Opening Date, FD Account No, Interest, Banks, Name]
          const expectedCols = headerArray.length - 1;
          const newRows = [];
          for (let r = dataStart; r < csvRows.length; r++) {
            const csvRow = csvRows[r];
            const out = new Array(expectedCols).fill('');
            if (mapping) {
              for (let ti = 0; ti < expectedCols; ti++) {
                const ci = mapping[ti];
                if (ci >= 0 && ci < csvRow.length) out[ti] = (csvRow[ci] || '').toString().trim();
              }
            } else {
              // take first expectedCols columns from CSV row
              for (let ci = 0; ci < expectedCols && ci < csvRow.length; ci++) out[ci] = (csvRow[ci] || '').toString().trim();
            }
            // skip empty rows (all empty)
            if (out.every(c => c === '')) continue;
            newRows.push(out);
          }

          if (newRows.length === 0) { alert('No data rows found in CSV'); return; }

          // Replace items with loaded rows
          items.length = 0;
          newRows.forEach(rw => items.push(rw));
          // reset currentIndex so center is first page
          currentIndex = 0;
          updateListItems();
          // update slider
          if (typeof slider !== 'undefined') {
            slider.max = items.length;
            slider.value = 1;
            sliderValueDiv.textContent = slider.value;
          }
          // invalidate search cache
          _searchItemsVersion = items.length;
          _searchMatches = [];
          _searchPos = -1;
          // focus center editable cell
          setTimeout(() => {
            const centerRow = listBody.querySelectorAll('.list-item')[3];
            if (centerRow) {
              const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
              if (firstEditableCell) firstEditableCell.focus();
            }
          }, 10);
          alert(`Loaded ${newRows.length} rows from CSV`);
        };
        reader.readAsText(file, 'utf-8');
      };
      // trigger file picker
      input.click();
    });
    // Accrued Interest button handler
    document.getElementById('accrued-btn').addEventListener('click', function() {
      const fyInput = prompt('Enter financial year to report (format: FY-YY-YY, e.g. FY-21-22):');
      if (!fyInput) return;
      const m = fyInput.match(/FY-(\d{2})-(\d{2})/i);
      if (!m) { alert('Invalid FY format. Expected FY-YY-YY'); return; }
      const startYear = 2000 + parseInt(m[1], 10);
      const endYear = 2000 + parseInt(m[2], 10);
      const fyStart = new Date(startYear, 3, 1); // 1 April
      const fyEnd = new Date(endYear, 2, 31, 23, 59, 59, 999); // 31 March

      function parseDateLocal(dateStr) {
        if (!dateStr || dateStr.trim() === '') return null;
        let d, mo, y;
        if (dateStr.includes('/')) [d, mo, y] = dateStr.split('/').map(x => parseInt(x,10));
        else if (dateStr.includes('-')) [d, mo, y] = dateStr.split('-').map(x => parseInt(x,10));
        else return null;
        if (y < 100) y += 2000;
        return new Date(y, mo - 1, d);
      }
      function yearsBetween(d1, d2) {
        return (d2 - d1) / (1000 * 60 * 60 * 24 * 365.2425);
      }

      const rowsToReport = [];
      let totalAccrued = 0;

      items.forEach((row, idx) => {
        const maturityDate = parseDateLocal(row[0]);
        const maturityAmt = parseFloat(String(row[1] || '').replace(/[^\d.\-]/g, '')) || 0;
        const principal = parseFloat(String(row[2] || '').replace(/[^\d.\-]/g, '')) || 0;
        if (!maturityDate || principal === 0) return;
        const openingDate = parseDateLocal(row[3]);

        // read rate (column index 5) and normalize to decimal
        let rate = parseFloat((row[5] || '').toString().trim());
        if (!isNaN(rate)) rate = rate > 1 ? rate / 100 : rate;
        else rate = 0;

        // estimate term years if opening date present
        let termYears = 1;
        if (openingDate) termYears = Math.max(0.0001, yearsBetween(openingDate, maturityDate));
        else if (rate && principal > 0 && maturityAmt > 0) termYears = Math.max(0.0001, Math.log(maturityAmt / principal) / Math.log(1 + rate));

        if (!rate && principal > 0 && maturityAmt > 0 && termYears > 0) {
          // derive implicit annual compound rate if not provided
          rate = Math.pow(maturityAmt / principal, 1 / termYears) - 1;
        }

        const lifeStart = openingDate || new Date(maturityDate.getTime() - termYears * 365.2425 * 24 * 3600 * 1000);
        const lifeEnd = maturityDate;
        const overlapStart = (lifeStart > fyStart) ? lifeStart : fyStart;
        const overlapEnd = (lifeEnd < fyEnd) ? lifeEnd : fyEnd;
        if (overlapEnd < overlapStart) return;

        // If maturity amount equals principal => this deposit pays interest out (simple interest
        // credited monthly). Compute accrued interest for the FY using simple monthly credit logic.
        let accrued = 0;
        const isSimpleMonthly = Math.abs(maturityAmt - principal) < 0.01;
        if (isSimpleMonthly) {
          // compute overlap days and prorate by year length
          const msPerDay = 1000 * 60 * 60 * 24;
          const overlapDays = Math.round((overlapEnd.getTime() - overlapStart.getTime()) / msPerDay) + 1;
          // simple interest accrued over overlap days (monthly credits assumed; per-day prorate)
          accrued = principal * rate * (overlapDays / 365.2425);
        } else {
          // compound case (existing behaviour)
          const tStart = yearsBetween(lifeStart, overlapStart);
          const tEnd = yearsBetween(lifeStart, overlapEnd);
          const valueAtStart = principal * Math.pow(1 + rate, tStart);
          const valueAtEnd = principal * Math.pow(1 + rate, tEnd);
          accrued = valueAtEnd - valueAtStart;
        }

        totalAccrued += accrued;
        rowsToReport.push({ idx: idx + 1, row, maturityDate, principal, maturityAmt, rate, accrued });
      });

      // Aggregate accrued by individual
      const personTotals = {}; // name -> accrued sum (raw)
      rowsToReport.forEach(item => {
        const name = (item.row[item.row.length - 1] || '').toString().trim() || 'Unknown';
        personTotals[name] = (personTotals[name] || 0) + item.accrued;
      });

      function formatINR(num) { return num.toLocaleString('en-IN'); }
      let html = `<!doctype html><html><head><meta charset='utf-8'><title>Accrued Interest ${fyInput}</title><style>body{font-family:Arial;margin:20px}table{width:100%;border-collapse:collapse}th,td{border:1px solid #888;padding:6px;text-align:center}th{background:#e8eef6} .right{text-align:right}</style></head><body><h1>Accrued Interest Report for ${fyInput}</h1>`;
      html += `<p>Total deposits listed: ${rowsToReport.length}</p>`;
      html += '<table><thead><tr><th>Sr</th>';
      for (let i=0;i<headerArray.length-1;i++) html += `<th>${headerArray[i+1]}</th>`;
      html += '<th>Rate(%)</th><th>Accrued (‚Çπ)</th></tr></thead><tbody>';
      rowsToReport.forEach(item => {
        html += `<tr><td>${item.idx}</td>`;
        for (let i=0;i<item.row.length;i++) html += `<td>${item.row[i]}</td>`;
        html += `<td>${(item.rate*100).toFixed(3)}</td><td class="right">‚Çπ ${formatINR(Math.round(item.accrued))}</td></tr>`;
      });
      html += `</tbody></table>`;

      // Per-person totals table
      html += `<h2>Accrued Interest by Individual for ${fyInput}</h2>`;
      html += `<table><thead><tr><th>Name</th><th class="right">Total Accrued (‚Çπ)</th></tr></thead><tbody>`;
      Object.keys(personTotals).sort((a,b) => personTotals[b] - personTotals[a]).forEach(name => {
        html += `<tr><td style="text-align:left;padding-left:10px">${name}</td><td class="right">‚Çπ ${formatINR(Math.round(personTotals[name]))}</td></tr>`;
      });
      html += `</tbody></table>`;

      html += `<h3>Total Accrued Interest for ${fyInput}: ‚Çπ ${formatINR(Math.round(totalAccrued))}</h3></body></html>`;

      const win = window.open('', '_blank');
      if (win) { win.document.write(html); win.document.close(); } else { alert('Allow pop-ups to view report.'); }
    });
    // When the user releases the mouse button after moving the slider, jump to the record number
    slider.addEventListener('change', function() {
      const rowNumber = parseInt(slider.value, 10);
      // Only jump if within valid range (1 to items.length)
      if (!isNaN(rowNumber) && rowNumber >= 1 && rowNumber <= items.length) {
        currentIndex = (rowNumber - 1) % items.length;
        currentIndex = rowNumber - 4;
        if (currentIndex < 1) currentIndex = currentIndex + items.length;
        updateListItems();
        const centerRow = listBody.querySelectorAll('.list-item')[3];
        const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
        if (firstEditableCell) {
          firstEditableCell.focus();
        }
      }
    });

    // Map mouse wheel (over the list container) to slider movement and record jump
    listContainer.addEventListener('wheel', function(e) {
      // Only handle when enough time has passed to avoid excessive jumps
      const now = Date.now();
      if (now - _lastWheelAt < _wheelThrottleMs) {
        e.preventDefault();
        return;
      }
      _lastWheelAt = now;
      e.preventDefault();
      const delta = Math.sign(e.deltaY); // 1 => wheel down, -1 => wheel up
      const min = parseInt(slider.min, 10) || 1;
      const max = parseInt(slider.max, 10) || items.length || 1;
      let newVal = parseInt(slider.value, 10) + delta;
      if (newVal < min) newVal = min;
      if (newVal > max) newVal = max;
      if (newVal !== parseInt(slider.value, 10)) {
        slider.value = newVal;
        // update visible slider value immediately
        sliderValueDiv.textContent = slider.value;
        // Trigger the same logic as when the user releases the slider
        slider.dispatchEvent(new Event('change'));
      }
    }, { passive: false });
    // Sort on maturity date
    const sortBtn = document.getElementById('sort-btn');
    sortBtn.addEventListener('click', function() {
      // Function to parse date string and convert to Date object for comparison
      function parseDate(dateStr) {
        if (!dateStr || dateStr.trim() === '') {
          return new Date(0); // Return epoch date for empty dates (will sort to beginning)
        }
        // Try different date formats that might be used
        let date;
        // Try DD/MM/YYYY format
        if (dateStr.includes('/')) {
          const parts = dateStr.split('/');
          if (parts.length === 3) {
            // Assume DD/MM/YYYY format
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in Date
            const year = parseInt(parts[2], 10);
            date = new Date(year, month, day);
          }
        }
        // Try DD-MM-YYYY format
        else if (dateStr.includes('-')) {
          const parts = dateStr.split('-');
          if (parts.length === 3) {
            // Assume DD-MM-YYYY format
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in Date
            const year = parseInt(parts[2], 10);
            date = new Date(year, month, day);
          }
        }
        // Try other formats or default to Date parsing
        else {
          date = new Date(dateStr);
        }
        // If date is invalid, return epoch date
        if (isNaN(date.getTime())) {
          return new Date(0);
        }
        return date;
      }
      // Sort the items array by maturity date (index 0 in each row)
      items.sort((a, b) => {
        const dateA = parseDate(a[0]); // Maturity Date is at index 0
        const dateB = parseDate(b[0]);
        return dateA.getTime() - dateB.getTime(); // Sort in ascending order
      });
      // Reset to first record after sorting
      currentIndex = 0;
      updateListItems();
      // Update slider to reflect new position
      slider.value = 1;
      sliderValueDiv.textContent = slider.value;
      // Focus on the first editable cell
      const centerRow = listBody.querySelectorAll('.list-item')[3];
      const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
      if (firstEditableCell) {
        firstEditableCell.focus();
      }
      alert('Data sorted by Maturity Date in ascending order.');
    });
    // ---------- Search functionality ----------
  function doSearch() {
    const qEl = document.getElementById('search-input');
    if (!qEl) return;
    const q = qEl.value.trim().toLowerCase();
    if (!q) { alert('Enter search text'); return; }
    if (!items || items.length === 0) { alert('No data to search'); return; }

    // Rebuild matches if query changed or items modified (simple version: compare length)
    if (q !== _searchLastQuery || _searchItemsVersion !== items.length) {
      _searchLastQuery = q;
      _searchMatches = [];
      _searchPos = -1;
      for (let i = 0; i < items.length; i++) {
        const row = items[i];
        for (let j = 0; j < row.length; j++) {
          const cellText = (row[j] || '').toString().toLowerCase();
          if (cellText.indexOf(q) !== -1) { _searchMatches.push(i); break; }
        }
      }
      _searchItemsVersion = items.length;
    }

    if (!_searchMatches || _searchMatches.length === 0) {
      alert('No match found.');
      return;
    }

    // advance to next match on successive clicks
    _searchPos = (_searchPos + 1) % _searchMatches.length;
    const foundIndex = _searchMatches[_searchPos];

    // Center the found row in the visible list (center position is index 3)
    currentIndex = foundIndex - 3;
    // normalize currentIndex into valid range
    if (items.length > 0) {
      currentIndex = ((currentIndex % items.length) + items.length) % items.length;
    } else {
      currentIndex = 0;
    }

    updateListItems();

    // Update slider to reflect found row (1-based)
    if (typeof slider !== 'undefined') {
      slider.max = items.length || 1;
      slider.value = Math.min(Math.max(1, foundIndex + 1), slider.max);
      if (typeof sliderValueDiv !== 'undefined') sliderValueDiv.textContent = slider.value;
    }

    // Focus first editable cell of center row
    const centerRow = listBody.querySelectorAll('.list-item')[3];
    if (centerRow) {
      const firstEditableCell = centerRow.querySelector('td:nth-child(2)');
      if (firstEditableCell) firstEditableCell.focus();
    }
  }

  // Attach search button and Enter-key handler
  const searchBtn = document.getElementById('search-btn');
  if (searchBtn) searchBtn.addEventListener('click', doSearch);
  const searchInput = document.getElementById('search-input');
  if (searchInput) searchInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      doSearch();
    }
  });

  // ---------- Update Totals (SUM) button handler ----------
  document.getElementById('update-totals-btn').addEventListener('click', function() {
    const tableMtd = document.getElementById('table-maturity-total');
    const tablePr  = document.getElementById('table-principal-total');
    const footerMtd = document.getElementById('footer-maturity-total');
    const footerPr  = document.getElementById('footer-principal-total');
  
    // If none of the target cells exist, nothing to do
    if ((!tableMtd || !tablePr) && (!footerMtd || !footerPr)) return;

    let totalMaturity = 0;
    let totalPrincipal = 0;

    // items: row[0]=Maturity Date, row[1]=Maturity Amt, row[2]=Principal Amt
    items.forEach((row) => {
      // sanitize value: remove any non-digit, non-dot, non-minus characters (currency symbols, spaces, commas)
      const rawM = String(row[1] || '');
      const rawP = String(row[2] || '');
      const cleanM = rawM.replace(/[^\d.\-]/g, '');
      const cleanP = rawP.replace(/[^\d.\-]/g, '');
      const m = cleanM === '' ? 0 : parseFloat(cleanM);
      const p = cleanP === '' ? 0 : parseFloat(cleanP);
      if (!isNaN(m)) totalMaturity += m;
      if (!isNaN(p)) totalPrincipal += p;
    });

    const mInt = Math.round(totalMaturity);
    const pInt = Math.round(totalPrincipal);
    const mStr = '‚Çπ ' + mInt.toLocaleString('en-IN');
    const pStr = '‚Çπ ' + pInt.toLocaleString('en-IN');

    if (tableMtd) tableMtd.textContent = mStr;
    if (tablePr)  tablePr.textContent  = pStr;
    if (footerMtd) footerMtd.textContent = mStr;
    if (footerPr)  footerPr.textContent  = pStr;
  });
  </script>
</body>
</html>
